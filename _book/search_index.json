[
["index.html", "Geostatystyka Rodział 1 Dzień dobry", " Geostatystyka Jakub Nowosad 2016-03-12   Rodział 1 Dzień dobry Kłaniam się.  Tutaj będzie wstęp mówiący o tym co znajduje się dalej     via GIPHY   "],
["intro.html", "Rodział 2 Wprowadzenie 2.1 Wymagania wstępne 2.2 R a dane przestrzenne 2.3 Import danych 2.4 Eksport danych 2.5 Wizualizacja danych 2D 2.6 Tworzenie siatek", " Rodział 2 Wprowadzenie  2.1 Wymagania wstępne Oprogramowanie, pakiety i dane.  2.1.1 Oprogramowanie  R - https://cloud.r-project.org/ RStudio - https://www.rstudio.com/products/rstudio/download/    2.1.2 Dane  Adres Pliki + ryciny     2.2 R a dane przestrzenne  2.2.1 Pakiety  GIS - sp, rgdal, raster, rasterVis, rgeos, maptools, GeoXp, deldir, pgirmess Geostatystyka - gstat, geoR, geoRglm, fields, spBayes, RandomFields, vardiag Inne - ggplot2, corrplot, caret  pakiety &lt;- c(&#39;caret&#39;, &#39;corrplot&#39;, &#39;dismo&#39;, &#39;fields&#39;, &#39;geoR&#39;, &#39;ggplot2&#39;, &#39;gridExtra&#39;, &#39;gstat&#39;, &#39;pgirmess&#39;, &#39;raster&#39;, &#39;rasterVis&#39;, &#39;rgdal&#39;, &#39;rgeos&#39;, &#39;sp&#39;) install.packages(pakiety) Pakiety R używane w tej książce można również zainstalować poprzez: devtools::install_github(&quot;nowosad/geostat_book&quot;)   2.2.2 Reprezentacja danych nieprzestrzennych  Wektory (ang. vector):  liczbowe (ang. integer, numeric) - c(1, 2, 3) i c(1.21, 3.32, 4.43) znakowe (ang. character) - c(‘jeden’, ‘dwa’, ‘trzy’) logiczne (ang. logical) - c(TRUE, FALSE) czynnikowe (ang. factor) - c(‘jeden’, ‘dwa’, ‘trzy’, ‘jeden’)  Ramki danych (ang. data.frame) - to zbiór zmiennych (kolumn) oraz obserwacji (wierszy) zawierających różne typy danych Macierze (ang. matrix) Listy (ang. list)    2.2.3 Reprezentacja danych przestrzennych  Obiekty klasy Spatial* z pakietu sp - wszystkie z nich zawierają dwie dodatkowe informacje:  bounding box (bbox) - obwiednia - określa zasięg danych CRS (proj4string) - układ współrzędnych  Najczęściej stosowane obiekty klasy Spatial* to SpatialPointsDataFrame, SpatialPolygonsDataFrame oraz SpatialGridDataFrame Obiekty klasy Raster* z pakietu raster, tj. RasterLayer, RasterStack, RasterBrick Inne    2.2.4 GDAL/OGR  http://www.gdal.org/ GDAL to biblioteka zawierająca funkcje służące do odczytywania i zapiswania danych w formatach rastrowych OGR to bibioteka służąca to odczytywania i zapiswania danych w formatach wektorowych Pakiet rgdal pozwala na wykorzystanie bibliotek GDAL/OGR w R    2.2.5 PROJ.4  Dane przestrzenne powinny być zawsze powiązane z układem współrzednych PROJ.4 - to biblioteka pozwalająca na identyfiację oraz konwersję pomiędzy różnymi układami współrzędnych http://www.spatialreference.org/    2.2.6 EPSG  Kod EPSG (ang. European Petroleum Survey Group) pozwala na łatwe identyfikowanie układów współrzędnych Przykładowo, układ PL 1992 może być określony jako:  “+proj=tmerc +lat_0=0 +lon_0=19 +k=0.9993 +x_0=500000 +y_0=-5300000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs”  …lub też za pomocą kodu EPSG:  “+init=epsg:2180”   2.2.7 Układ geograficzny  Proporcje pomiędzy współrzedną oznaczjącą długość geograficzną (X) a oznaczającą szerokość geograficzną (Y) nie są równe 1:1 Wielkość oczka siatki jest zmienna Nie pozwala to na proste określanie odległości czy powierzchni Jednostka mapy jest abstrakcyjna Do większości algorytmów w geostatystyce wykorzystywane są układy współrzędnych prostokątnych płaskich     2.3 Import danych  2.3.1 Dane punktowe (format csv) dane_punktowe &lt;- read.csv(&#39;dane/punkty.csv&#39;) head(dane_punktowe) ##       srtm clc      temp      ndvi      savi        x        y ## 1 225.0000   4  8.445198 0.2714581 0.1336594 748318.6 718215.9 ## 2 226.2811   1 26.459794 0.3990652 0.2777170 746796.4 713105.3 ## 3 202.1949   1 16.224041 0.5414072 0.3192062 755746.5 717561.6 ## 4 218.4167   1 19.477969 0.5021783 0.2769863 752826.7 713117.8 ## 5 196.3150   1 20.679498 0.4138057 0.2240249 748584.1 712664.4 ## 6 212.1392   2 20.844318 0.5492478 0.2501368 753884.3 713267.7 coordinates(dane_punktowe) &lt;- ~x+y summary(dane_punktowe) ## Object of class SpatialPointsDataFrame ## Coordinates: ##        min      max ## x 745619.3 756963.6 ## y 712664.4 721253.9 ## Is projected: NA  ## proj4string : [NA] ## Number of points: 252 ## Data attributes: ##       srtm            clc             temp             ndvi        ##  Min.   :145.8   Min.   :1.000   Min.   : 8.153   Min.   :0.1772   ##  1st Qu.:184.6   1st Qu.:1.000   1st Qu.:12.459   1st Qu.:0.4520   ##  Median :215.0   Median :1.000   Median :15.210   Median :0.5105   ##  Mean   :211.4   Mean   :1.508   Mean   :15.522   Mean   :0.4974   ##  3rd Qu.:235.4   3rd Qu.:2.000   3rd Qu.:18.258   3rd Qu.:0.5587   ##  Max.   :277.0   Max.   :4.000   Max.   :26.700   Max.   :0.6955   ##       savi         ##  Min.   :0.05808   ##  1st Qu.:0.27785   ##  Median :0.31928   ##  Mean   :0.31185   ##  3rd Qu.:0.35793   ##  Max.   :0.46736 proj4string(dane_punktowe) &lt;- &#39;+init=epsg:2180&#39; summary(dane_punktowe) ## Object of class SpatialPointsDataFrame ## Coordinates: ##        min      max ## x 745619.3 756963.6 ## y 712664.4 721253.9 ## Is projected: TRUE  ## proj4string : ## [+init=epsg:2180 +proj=tmerc +lat_0=0 +lon_0=19 +k=0.9993 ## +x_0=500000 +y_0=-5300000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 ## +units=m +no_defs] ## Number of points: 252 ## Data attributes: ##       srtm            clc             temp             ndvi        ##  Min.   :145.8   Min.   :1.000   Min.   : 8.153   Min.   :0.1772   ##  1st Qu.:184.6   1st Qu.:1.000   1st Qu.:12.459   1st Qu.:0.4520   ##  Median :215.0   Median :1.000   Median :15.210   Median :0.5105   ##  Mean   :211.4   Mean   :1.508   Mean   :15.522   Mean   :0.4974   ##  3rd Qu.:235.4   3rd Qu.:2.000   3rd Qu.:18.258   3rd Qu.:0.5587   ##  Max.   :277.0   Max.   :4.000   Max.   :26.700   Max.   :0.6955   ##       savi         ##  Min.   :0.05808   ##  1st Qu.:0.27785   ##  Median :0.31928   ##  Mean   :0.31185   ##  3rd Qu.:0.35793   ##  Max.   :0.46736    2.3.2 Dane poligonowe (formaty gisowe) granica &lt;- readOGR(dsn=&#39;dane&#39;, layer=&#39;granica&#39;, verbose=FALSE) plot(granica)    2.3.3 Rastry siatka_raster &lt;- raster(&#39;dane/siatka.tif&#39;) plot(siatka_raster)     2.4 Eksport danych  2.4.1 Zapisywanie danych wektorowych writeOGR(poligon, dsn=&#39;nazwa_folderu&#39;, layer=&#39;nowy_poligon&#39;, driver=&#39;ESRI Shapefile&#39;)   2.4.2 Zapisywanie danych rastrowych writeRaster(siatka_raster, filename=&#39;nazwa_folderu/nowy_raster.tif&#39;)    2.5 Wizualizacja danych 2D  2.5.1 Dane punktowe plot(dane_punktowe)  spplot(dane_punktowe, &#39;temp&#39;)  spplot(dane_punktowe, &#39;srtm&#39;)    2.5.2 Dane punktowe - kategorie dane_punktowe@data$clc &lt;- as.factor(dane_punktowe@data$clc) spplot(dane_punktowe, &#39;clc&#39;)    2.5.3 Rastry levelplot(siatka_raster, margin=FALSE)     2.6 Tworzenie siatek  2.6.1 Siatki regularne bbox(dane_punktowe) ##        min      max ## x 745619.3 756963.6 ## y 712664.4 721253.9 extent(dane_punktowe) ## class       : Extent  ## xmin        : 745619.3  ## xmax        : 756963.6  ## ymin        : 712664.4  ## ymax        : 721253.9 siatka &lt;- expand.grid(x = seq(from = 745050, to = 757050, by = 500),                       y = seq(from = 712650, to = 721650, by = 500)) coordinates(siatka) &lt;- ~x + y gridded(siatka) &lt;- TRUE proj4string(siatka) &lt;- proj4string(dane_punktowe) siatka &lt;- makegrid(dane_punktowe, cellsize=500) names(siatka) &lt;- c(&#39;x&#39;, &#39;y&#39;) coordinates(siatka) &lt;- ~x + y gridded(siatka) &lt;- TRUE proj4string(siatka) &lt;- proj4string(dane_punktowe)   2.6.2 Siatki regularne plot(siatka) plot(dane_punktowe, add=TRUE)    2.6.3 Siatki nieregularne - klasa RasterLayer granica &lt;- readOGR(dsn=&#39;dane&#39;, layer=&#39;granica&#39;) ## OGR data source with driver: ESRI Shapefile  ## Source: &quot;dane&quot;, layer: &quot;granica&quot; ## with 1 features ## It has 3 fields siatka_n &lt;- raster(extent(granica)) res(siatka_n) &lt;- c(500, 500) siatka_n[] &lt;- 0 proj4string(siatka_n) &lt;- proj4string(granica) siatka_n &lt;- mask(siatka_n, granica) levelplot(siatka_n, margin=FALSE)    2.6.4 Siatki nieregularne - klasa SpatialPixelsDataFrame siatka_n &lt;- as(siatka_n, &#39;SpatialPointsDataFrame&#39;) siatka_n &lt;- siatka_n[!is.na(siatka_n@data$layer), ] gridded(siatka_n) &lt;- TRUE plot(siatka_n)     "],
["eksploracyjna-analiza-danych.html", "Rodział 3 Eksploracyjna analiza danych 3.1 Eksploracyjna analiza danych | Cel 3.2 Dane 3.3 Statystyki opisowe 3.4 Wykresy 3.5 Porównanie zmiennych 3.6 Transformacje danych 3.7 Mapy 3.8 Rozgrupowanie danych", " Rodział 3 Eksploracyjna analiza danych  3.1 Eksploracyjna analiza danych | Cel  Ogólna charakterystyka danych oraz badanego zjawiska Określenie przestrzennego/czasowego typu próbkowania Informacja o relacji pomiędzy lokalizacją obserwacji a czynnikami wpływającymi na zmienność przestrzenną cechy    3.2 Dane  3.2.1 Dane punkty &lt;- read.csv(&#39;dane/punkty.csv&#39;) coordinates(punkty) &lt;- ~x+y  proj4string(punkty) &lt;- &#39;+init=epsg:2180&#39; par(mar=c(rep(0, 4))) plot(punkty)  str(punkty) ## Formal class &#39;SpatialPointsDataFrame&#39; [package &quot;sp&quot;] with 5 slots ##   ..@ data       :&#39;data.frame&#39;:  252 obs. of  5 variables: ##   .. ..$ srtm: num [1:252] 225 226 202 218 196 ... ##   .. ..$ clc : int [1:252] 4 1 1 1 1 2 1 2 1 1 ... ##   .. ..$ temp: num [1:252] 8.45 26.46 16.22 19.48 20.68 ... ##   .. ..$ ndvi: num [1:252] 0.271 0.399 0.541 0.502 0.414 ... ##   .. ..$ savi: num [1:252] 0.134 0.278 0.319 0.277 0.224 ... ##   ..@ coords.nrs : int [1:2] 6 7 ##   ..@ coords     : num [1:252, 1:2] 748319 746796 755747 752827 748584 ... ##   .. ..- attr(*, &quot;dimnames&quot;)=List of 2 ##   .. .. ..$ : chr [1:252] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; ... ##   .. .. ..$ : chr [1:2] &quot;x&quot; &quot;y&quot; ##   ..@ bbox       : num [1:2, 1:2] 745619 712664 756964 721254 ##   .. ..- attr(*, &quot;dimnames&quot;)=List of 2 ##   .. .. ..$ : chr [1:2] &quot;x&quot; &quot;y&quot; ##   .. .. ..$ : chr [1:2] &quot;min&quot; &quot;max&quot; ##   ..@ proj4string:Formal class &#39;CRS&#39; [package &quot;sp&quot;] with 1 slot ##   .. .. ..@ projargs: chr &quot;+init=epsg:2180 +proj=tmerc +lat_0=0 +lon_0=19 +k=0.9993 +x_0=500000 +y_0=-5300000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m&quot;| __truncated__ str(punkty@data) ## &#39;data.frame&#39;:    252 obs. of  5 variables: ##  $ srtm: num  225 226 202 218 196 ... ##  $ clc : int  4 1 1 1 1 2 1 2 1 1 ... ##  $ temp: num  8.45 26.46 16.22 19.48 20.68 ... ##  $ ndvi: num  0.271 0.399 0.541 0.502 0.414 ... ##  $ savi: num  0.134 0.278 0.319 0.277 0.224 ... granica &lt;- readOGR(&#39;dane&#39;, &#39;granica&#39;) ## OGR data source with driver: ESRI Shapefile  ## Source: &quot;dane&quot;, layer: &quot;granica&quot; ## with 1 features ## It has 3 fields plot(granica, add=TRUE)     3.3 Statystyki opisowe  3.3.1 Statystyki opisowe summary(punkty@data) ##       srtm            clc             temp             ndvi        ##  Min.   :145.8   Min.   :1.000   Min.   : 8.153   Min.   :0.1772   ##  1st Qu.:184.6   1st Qu.:1.000   1st Qu.:12.459   1st Qu.:0.4520   ##  Median :215.0   Median :1.000   Median :15.210   Median :0.5105   ##  Mean   :211.4   Mean   :1.508   Mean   :15.522   Mean   :0.4974   ##  3rd Qu.:235.4   3rd Qu.:2.000   3rd Qu.:18.258   3rd Qu.:0.5587   ##  Max.   :277.0   Max.   :4.000   Max.   :26.700   Max.   :0.6955   ##       savi         ##  Min.   :0.05808   ##  1st Qu.:0.27785   ##  Median :0.31928   ##  Mean   :0.31185   ##  3rd Qu.:0.35793   ##  Max.   :0.46736   3.3.2 Statystyki opisowe | średnia i mediana median(punkty$temp, na.rm=TRUE) ## [1] 15.20954 mean(punkty$temp, na.rm=TRUE) ## [1] 15.52164   3.3.3 Statystyki opisowe | średnia i mediana  W wypadku symetrycznego rozkładu te dwie cechy są równe Średnia jest bardziej wrażliwa na wartości odstające Mediana jest lepszą miarą środka danych, jeżeli są one skośne  Po co używać średniej?  Bardziej przydatna w przypadku małych zbiorów danych Gdy rozkład danych jest symetryczny (Jednak) często warto podawać obie miary    3.3.4 Statystyki opisowe | minimum i maksimum min(punkty$temp, na.rm=TRUE) ## [1] 8.153331 max(punkty$temp, na.rm=TRUE) ## [1] 26.69978   3.3.5 Statystyki opisowe | ochylenie standardowe     sd(punkty$temp, na.rm=TRUE) ## [1] 4.079184    3.4 Wykresy  3.4.1 Histogram ggplot(punkty@data, aes(temp)) + geom_histogram()   Stworzony przez Karla Pearsona Jest graficzną reprezentacją rozkładu  danych Wartości danych są łączone w przedziały (na osi poziomej) a na osi pionowej jest ukazana liczba punktów (obserwacji) w każdym przedziale Różny dobór przedziałów może dawać inną informację W pakiecie ggplot2, domyślnie przedział to zakres/30    3.4.2 Estymator jądrowy gęstości (ang. kernel density estimation) ggplot(punkty@data, aes(temp)) + geom_density()    3.4.3 Wykresy kwantyl-kwantyl (ang.quantile-quantile) ggplot(punkty@data, aes(sample=temp)) + stat_qq()    3.4.4 Wykresy kwantyl-kwantyl (ang. quantile-quantile) http://stats.stackexchange.com/questions/101274/how-to-interpret-a-qq-plot    3.4.5 Dystrybuanta (CDF)  Dystrybuanta (ang. conditional density function - CDF) wyświetla prawdopodobieństwo, że wartość zmiennej przewidywanej jest mniejsza lub równa określonej wartości  ggplot(punkty@data, aes(temp)) + stat_ecdf()     3.5 Porównanie zmiennych  3.5.1 Kowariancja  Kowariancja jest nieunormowaną miarą zależności liniowej pomiędzy dwiema zmiennymi Kowariancja dwóch zmiennych \\(x\\) i \\(y\\) pokazuje jak dwie zmienne są ze sobą liniowo powiązane Dodatnia kowariancja wzkazuje na pozytywną relację liniową pomiędzy zmiennymi, podczas gdy ujemna kowariancja świadczy o odwrotnej sytuacji Jeżeli zmienne nie są ze sobą liniowo powiązane, wartość kowariacji jest bliska zeru Inaczej mówiąc, kowariancja stanowi miarę wspólnej zmienności dwóch zmiennych  Wielkość samej kowariancji uzależniona jest od przyjętej skali zmiennej (jednostki) Inne wyniku uzyskamy (przy tej samej zależności pomiędzy parą zmiennych), gdy będziemy analizować wyniki np. wieku i dochodu w złotówkach a inne dla wieku i dochodu w dolarach  cov(punkty$temp, punkty$ndvi, use= &#39;complete.obs&#39;) ## [1] 0.02515738   3.5.2 Współczynnik korelacji  Wspołczynnik korelacji to unormowana miara zależności pomiędzy dwiema zmiennymi, przyjmująca wartości od -1 do 1 Współczynnik korelacji jest uzyskiwany poprzez podzielenie wartości kowariancji przez odchylenie standardowe wyników Z racji unormowania nie jest ona uzależniona od jednostki  ggplot(punkty@data, aes(temp, ndvi)) + geom_point()  cor(punkty$temp, punkty$ndvi, use= &#39;complete.obs&#39;) ## [1] 0.0642325 cor.test(punkty$temp, punkty$ndvi) ##  ##  Pearson&#39;s product-moment correlation ##  ## data:  punkty$temp and punkty$ndvi ## t = 1.0177, df = 250, p-value = 0.3098 ## alternative hypothesis: true correlation is not equal to 0 ## 95 percent confidence interval: ##  -0.05981513  0.18632640 ## sample estimates: ##       cor  ## 0.0642325 cor(punkty@data[c(1, 3:5)], use= &#39;complete.obs&#39;) ##            srtm        temp      ndvi       savi ## srtm  1.0000000 -0.03717220 0.1116264 0.09361020 ## temp -0.0371722  1.00000000 0.0642325 0.04570619 ## ndvi  0.1116264  0.06423250 1.0000000 0.94296709 ## savi  0.0936102  0.04570619 0.9429671 1.00000000 corrplot(cor(punkty@data[c(1, 3:5)], use= &#39;complete.obs&#39;))    3.5.3 Wykresy pudełkowe punkty$clc &lt;- as.factor(punkty$clc) ggplot(punkty@data, aes(clc, temp)) + geom_boxplot()   Obrazuje pięc podstawowych statystyk opisowych oraz wartości odstające Pudełko to zakres międzykwantylowy Linie oznaczają najbardziej ekstremalne wartości, ale nie odstające. Górna to 1,5*IQR ponad krawędź pudełka, dolna to 1,5*IQR poniżej wartości dolnej krawędzi pudełka Linia środkowa to mediana     3.5.4 Testowanie istotności różnić średniej pomiędzy grupami punkty$clc &lt;- as.factor(punkty$clc) aov_test &lt;- aov(temp~clc, data=punkty) summary(aov_test) ##              Df Sum Sq Mean Sq F value Pr(&gt;F)     ## clc           2   1577   788.4   75.51 &lt;2e-16 *** ## Residuals   249   2600    10.4                    ## --- ## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1   3.5.5 Testowanie istotności różnić średniej pomiędzy grupami ## null device  ##           1 tukey &lt;- TukeyHSD(aov_test, &#39;clc&#39;) plot(tukey, las=1)     3.6 Transformacje danych  3.6.1 Transformacje danych  Transformacja danych może mieć na celu ułatwienie porównywania różnych zmiennych, zniwelowanie skośności rozkładu lub też zmniejszenie wpływu danych odstających Centrowanie i skalowanie (standaryzacja):  Centrowanie danych - wybierana jest przeciętna wartość predyktora, a następnie od wszystkich wartości predyktorów odejmowana jest wybrana wcześniej wartość Skalowanie danych - dzielenie każdej wartości predyktora przez jego odchylenie standardowe Wadą tego podjeścia jest główne zmniejszenie interpretowalności pojedynczych wartości  Redukcja skośności:  Logarytmizacja Pierwiastkowanie Rodzina transformacji Boxa Coxa Inne     3.6.2 Transformacja danych | Logarytmizacja ggplot(punkty@data, aes(temp)) + geom_density()  punkty$log_tpz &lt;- log(punkty$temp) ggplot(punkty@data, aes(log_tpz)) + geom_density()  punkty$exp_tpz &lt;- exp(punkty$log_tpz) ggplot(punkty@data, aes(exp_tpz)) + geom_density()    3.6.3 Transformacja danych | Pierwiastkowanie ggplot(punkty@data, aes(temp)) + geom_density()  punkty$sqrt_tpz &lt;- sqrt(punkty$temp) ggplot(punkty@data, aes(sqrt_tpz)) + geom_density()  punkty$pow_tpz &lt;- punkty$sqrt_tpz^2 ggplot(punkty@data, aes(pow_tpz)) + geom_density()    3.6.4 Transformacja danych | Rodzina transformacji Boxa Coxa ggplot(punkty@data, aes(temp)) + geom_density()  transformacja &lt;- BoxCoxTrans(punkty$temp) transformacja ## Box-Cox Transformation ##  ## 252 data points used to estimate Lambda ##  ## Input data summary: ##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  ##   8.153  12.460  15.210  15.520  18.260  26.700  ##  ## Largest/Smallest: 3.27  ## Sample Skewness: 0.474  ##  ## Estimated Lambda: 0.1  ## With fudge factor, Lambda = 0 will be used for transformations punkty$bc_tpz &lt;- predict(transformacja, punkty$temp) ggplot(punkty@data, aes(bc_tpz)) + geom_density()  invBoxCox &lt;- function(x, lambda) if (lambda == 0) exp(x) else (lambda*x + 1)^(1/lambda)  punkty$bc_tpz_inv &lt;- invBoxCox(punkty$bc_tpz, lambda=-0.3) ggplot(punkty@data, aes(bc_tpz_inv)) + geom_density()     3.7 Mapy  3.7.1 Podstawowe terminy | Kontekst przestrzenny  Populacja - cały obszar, dla którego chcemy określić wybrane właściwości Próba - zbiór obserwacji, dla których mamy informacje. Inaczej, próba to podzbiór populacji. Zazwyczaj niemożliwe (lub bardzo kosztowne) jest zdobycie informacji o całej populacji. Z tego powodu bardzo cenne jest odpowiednie wykorzystanie informacji z próby.    3.7.2 Mapy punktowe | Cel  Sprawdzenie poprawności współrzędnych Wgląd w typ próbkowania Sprawdzenie poprawności danych - dane odstające lokalnie Identyfikacja głównych cech struktury przestrzennej zjawiska (np. trend)    3.7.3 Typ próbowania  Regularny Losowy Losowy stratyfikowany Preferencyjny Liniowy    3.7.4 Typ próbowania | Regularny set.seed(225) regularny &lt;- spsample(granica, 150, type = &#39;regular&#39;) plot(regularny)   Zmienna offset    3.7.5 Typ próbowania | Losowy set.seed(301) losowy &lt;- spsample(granica, 150, type = &#39;random&#39;) plot(losowy)   Każda lokalizacja ma takie samo prawdopodobieństwo wystąpienia Każdy punkt jest losowany niezależnie od pozostałych    3.7.6 Typ próbowania | Losowy stratyfikowany set.seed(125) strat &lt;- spsample(granica, 150, type = &#39;stratified&#39;) plot(strat)    3.7.7 Typ próbowania | Preferencyjny I set.seed(425) pref &lt;- spsample(granica, 150, type = &#39;clustered&#39;, nclusters=80) plot(pref)    3.7.8 Typ próbowania | Liniowy # library(&#39;rgdal&#39;) # linia &lt;- readOGR(&quot;data&quot;, &quot;linia&quot;, verbose=FALSE) # set.seed(224) # izoliniowy &lt;- spsample(linia, 150, type = &#39;regular&#39;) # plot(izoliniowy)   3.7.9 Mapy punktowe i dane lokalnie odstające par(mar=c(rep(0, 4))) granica &lt;- readOGR(dsn=&#39;dane&#39;, layer=&#39;granica&#39;, verbose=FALSE)  plot(granica)  plot(punkty, add=TRUE)   # select.spatial(punkty, digitize=FALSE, rownames=TRUE) spplot(punkty, &#39;temp&#39;, identify=TRUE) spplot(punkty, &#39;temp&#39;, sp.layout = granica)     3.8 Rozgrupowanie danych  3.8.1 Rozgrupowanie danych  Istnieje szereg metod rozgrupowywania danych, między innymi:  Rozgrupowywanie komórkowe Rozgrupowywanie poligonowe  Celem tych metod jest nadanie wag obserwacjom w celu zapewnienia reprezentatywności przestrzennej danych    3.8.2 Rozgrupowanie danych punkty_pref &lt;- read.csv(&#39;dane/punkty_pref.csv&#39;) coordinates(punkty_pref) &lt;- ~x+y proj4string(punkty_pref) &lt;- &#39;+init=epsg:2180&#39; spplot(punkty_pref, &#39;temp&#39;)  summary(punkty_pref$temp) ##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  ##   8.205  12.490  15.480  15.580  17.930  26.440   3.8.3 Rozgrupowanie komórkowe I | (ang. cell declustering) \\[w&#39;_j=\\frac{\\frac{1}{n_i}}{\\text{liczba komórek z danymi}} \\cdot n\\] , gdzie \\(n_i\\) to liczba obserwacji w komórce, a \\(n\\) to łączna liczba obserwacji   3.8.4 Rozgrupowanie komórkowe I | (ang. cell declustering) punkty_pref &lt;- read.csv(&#39;dane/punkty_pref.csv&#39;) punkty_pref$id &lt;- 1:nrow(punkty_pref) coordinates(punkty_pref) &lt;- ~x+y proj4string(punkty_pref) &lt;- &#39;+init=epsg:2180&#39; spplot(punkty_pref, &#39;id&#39;, colorkey=TRUE)  granica &lt;- readOGR(dsn = &#39;dane&#39;, layer = &#39;granica&#39;, verbose = FALSE) siatka_n &lt;- raster(extent(granica)) # siatka_n &lt;- raster(xmn=450000, xmx=485000, ymn=5960000, ymx=5989000) res(siatka_n) &lt;- c(500, 500) siatka_n[] &lt;- 0 proj4string(siatka_n) &lt;- CRS(proj4string(punkty_pref)) siatka_n &lt;- mask(siatka_n, gBuffer(granica, width = 500)) siatka_n &lt;- as(siatka_n, &#39;SpatialPolygonsDataFrame&#39;) siatka_n &lt;- siatka_n[!is.na(siatka_n@data$layer), ] plot(siatka_n) plot(punkty_pref, add=TRUE)  punkty_pref$liczebnosc &lt;- rep(0, length(punkty_pref)) siatka_nr &lt;- aggregate(punkty_pref[&#39;liczebnosc&#39;], by = siatka_n, FUN = length)  spplot(siatka_nr, &#39;liczebnosc&#39;)  liczba &lt;- over(punkty_pref, siatka_nr) punkty_pref$waga &lt;- ((1/liczba$liczebnosc)/sum(!is.na(siatka_nr$liczebnosc))) * length(punkty_pref)  spplot(punkty_pref, &#39;waga&#39;)  srednia_arytmetyczna &lt;- mean(punkty_pref$temp) srednia_wazona_c1 &lt;- mean(punkty_pref$temp * punkty_pref$waga, na.rm=TRUE)   3.8.5 Rozgrupowanie komórkowe II | (ang. cell declustering)  punkty_pref &lt;- read.csv(&#39;dane/punkty_pref.csv&#39;) punkty_pref$id &lt;- 1:nrow(punkty_pref) coordinates(punkty_pref) &lt;- ~x+y proj4string(punkty_pref) &lt;- &#39;+init=epsg:2180&#39; spplot(punkty_pref, &#39;id&#39;, colorkey=TRUE)  granica &lt;- readOGR(dsn=&#39;dane&#39;, layer=&#39;granica&#39;, verbose=FALSE) siatka_n &lt;- raster(extent(granica)) res(siatka_n) &lt;- c(500, 500) siatka_n[] &lt;- 0 proj4string(siatka_n) &lt;- CRS(proj4string(punkty_pref)) siatka_n &lt;- mask(siatka_n, granica) siatka_n &lt;- as(siatka_n, &#39;SpatialPointsDataFrame&#39;) siatka_n &lt;- siatka_n[!is.na(siatka_n@data$layer), ] gridded(siatka_n) &lt;- TRUE plot(siatka_n)  out &lt;-  krige(id~1, punkty_pref, siatka_n, nmax=1) ## [inverse distance weighted interpolation] spplot(out, &#39;var1.pred&#39;)  df &lt;- as.data.frame(table(out[[1]])) df$waga &lt;- df$Freq/sum(df$Freq) punkty_pref &lt;- merge(punkty_pref, df, by.x=&#39;id&#39;, by.y=&#39;Var1&#39;) summary(punkty_pref$waga) ##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA&#39;s  ## 0.00389 0.00389 0.00389 0.00546 0.00778 0.01167      56 spplot(out, &#39;var1.pred&#39;, sp.layout=list(&#39;sp.points&#39;, punkty_pref))  spplot(punkty_pref[&#39;waga&#39;])  srednia_arytmetyczna &lt;- mean(punkty_pref$temp) srednia_wazona_c2 &lt;- sum(punkty_pref$temp * punkty_pref$waga, na.rm=TRUE)   3.8.6 Rozgrupowanie poligonowe | (ang. polygon declustering) \\[w&#39;_j=\\frac{area_j}{\\sum_{j=1}^{n}area_j} \\cdot n\\] , gdzie \\(area_j\\) powierzchnia dla wybranej obserwacji, a \\(n\\) to łączna liczba obserwacji   3.8.7 Rozgrupowanie poligonowe | (ang. polygon declustering) punkty_pref &lt;- read.csv(&#39;dane/punkty_pref.csv&#39;) punkty_pref$id &lt;- 1:nrow(punkty_pref) coordinates(punkty_pref) &lt;- ~x+y proj4string(punkty_pref) &lt;- &#39;+init=epsg:2180&#39; spplot(punkty_pref, &#39;id&#39;, colorkey=TRUE)  v &lt;- voronoi(punkty_pref) plot(punkty_pref, cex=0.2, col=&#39;red&#39;) plot(v, add=TRUE)  v_intersect &lt;-intersect(granica, v) plot(punkty_pref, cex=0.2, col=&#39;red&#39;) plot(v_intersect, add=TRUE)  v_intersect$pow &lt;- area(v_intersect) v_intersect$waga &lt;- v_intersect$pow/sum(v_intersect$pow) * length(punkty_pref)  punkty_pref &lt;- merge(punkty_pref, v_intersect[c(&#39;id&#39;, &#39;waga&#39;)], by=&#39;id&#39;) spplot(punkty_pref, &#39;waga&#39;)  srednia_arytmetyczna &lt;- mean(punkty_pref$temp, na.rm=TRUE) srednia_wazona_p &lt;- mean(punkty_pref$temp*punkty_pref$waga, na.rm=TRUE)     Średnia arytmetyczna     Populacja 15.59128   Próba 15.58453   Rozgrupowanie komórkowe I 17.88282   Rozgrupowanie komórkowe II 15.17018   Rozgrupowanie poligonowe 17.61604        "],
["eksploracyjna-analiza-danych-geostatystyka.html", "Rodział 4 Eksploracyjna analiza danych - geostatystyka 4.1 Interpolacja 4.2 Geostatystyka - prolog 4.3 Przestrzenna kowariancja, korelacja i semiwariancja 4.4 Anizotropia", " Rodział 4 Eksploracyjna analiza danych - geostatystyka  4.1 Interpolacja  4.1.1 Modele deterministyczne  Parametry tych modeli są zazwyczaj ustalane w oparciu o funkcję odległości lub powierzchni. Brakuje również szacunków na temat oceny błędu modelu. Np:  Funkcje wielomianowe Funkcje sklejane (ang. Splines) Triangulacje IDW (ang. Inverse Distance Weighted)   http://neondataskills.org/Data-Workshops/ESA15-Going-On-The-Grid-Spatial-Interpolation-Basics/   4.1.2 Modele deterministyczne punkty &lt;- read.csv(&#39;dane/punkty.csv&#39;) coordinates(punkty) &lt;- ~x+y proj4string(punkty) &lt;- &#39;+init=epsg:2180&#39; ras &lt;- raster(&#39;dane/siatka.tif&#39;) crs(ras) &lt;- proj4string(punkty) grid &lt;- as(ras, &#39;SpatialGridDataFrame&#39;) granica &lt;- readOGR(&#39;dane&#39;, &#39;granica&#39;) ## OGR data source with driver: ESRI Shapefile  ## Source: &quot;dane&quot;, layer: &quot;granica&quot; ## with 1 features ## It has 3 fields   4.1.3 Modele deterministyczne | Funkcje wielomianowe wielomian_1 &lt;- gstat(formula=temp~1, data=punkty, degree=1) wielomian_1_pred &lt;- predict(wielomian_1, newdata=grid) ## [ordinary or weighted least squares prediction] spplot(wielomian_1_pred[1], contour=TRUE,main=&#39;Powierzchnia trendu - wielomian pierwszego stopnia&#39;)  wielomian_2 &lt;- gstat(formula=temp~1, data=punkty, degree=2) wielomian_2_pred &lt;- predict(wielomian_2, newdata=grid) ## [ordinary or weighted least squares prediction] spplot(wielomian_2_pred[1], contour=TRUE,main=&#39;Powierzchnia trendu - wielomian drugiego stopnia&#39;)  wielomian_3 &lt;- gstat(formula=temp~1, data=punkty, degree=3) wielomian_3_pred &lt;- predict(wielomian_3, newdata=grid) ## [ordinary or weighted least squares prediction] spplot(wielomian_3_pred[1], contour=TRUE,main=&#39;Powierzchnia trendu - wielomian trzeciego stopnia&#39;)     4.1.4 Modele deterministyczne | Funkcje sklejane tps &lt;- Tps(coordinates(punkty), punkty@data$temp) ## Warning:  ## Grid searches over lambda (nugget and sill variances) with  minima at the endpoints:  ##   (GCV) Generalized Cross-Validation  ##    minimum at  right endpoint  lambda  =  2.084086e-06 (eff. df= 239.4 ) spline &lt;- interpolate(ras, tps) spline &lt;- mask(spline, ras) spplot(spline, contour=TRUE , main=&#39;Funkcje sklejane&#39;)    4.1.5 Modele deterministyczne | Triangulacje (Thiessen) voronoi_interp &lt;- voronoi(punkty) voronoi_interp &lt;- intersect(granica, voronoi_interp) spplot(voronoi_interp, &#39;temp&#39;, contour=TRUE, main=&#39;Poligony Voronoia&#39;)    4.1.6 Modele deterministyczne | IDW idw_wolin &lt;- idw(temp~1, punkty, grid, idp=2) ## [inverse distance weighted interpolation] spplot(idw_wolin, &#39;var1.pred&#39;, contour=TRUE, main=&#39;IDW&#39;)     4.1.7 Modele deterministyczne | Porównanie    4.1.8 Modele statystyczne  Parametry modeli są określane w oparciu o teorię prawdopodobieństwa. Dodatkowo wynik estymacji zawiera oszacowanie błędu. Np.:  Kriging Modele regresyjne Modele bayesowe Modele hybrydowe       4.2 Geostatystyka - prolog  4.2.1 Geostatystyka  Zbiór narzędzi statystycznych uwzględniających w analizie danych ich przestrzenną i czasową lokalizację, a opartych o teorię funkcji losowych.     4.2.2 Geostatystyka | Funkcje  Identyfikacja i modelowanie struktury przestrzennej/czasowej zjawiska Estymacja - szacowanie wartości badanej zmiennej w nieopróbowanym miejscu i/lub momencie czasu Symulacja - generowanie alternatywnych obrazów, które honorują wyniki pomiarów i strukturę przestrzenną/czasową zjawiska Optymalizacja próbkowania/sieci pomiarowej    4.2.3 Geostatystyczna analiza danych       4.2.4 Geostatystyka | Dane wejściowe  Wystarczająca duża liczba punktów (minimalnie &gt;30, ale zazwyczaj więcej niż 100/150) Są reprezentatywne Są niezależne Były stworzone używając stałej metodyki Są wystarczająco dokładne     4.2.5 Geostatystyka | Podstawowe etapy  Zaprojektowanie sposobu (typu) próbkowania oraz organizacji zadań Zebranie danych, analiza labolatoryjna Wstepna eksploracja danych, ocena ich jakości Modelowanie semiwariogramów na podstawie dostępnych danych Estymacja badanej cechy Porównanie i ocena modeli Stworzenie wynikowego produktu i jego dystrybucja     4.3 Przestrzenna kowariancja, korelacja i semiwariancja  4.3.1 Przestrzenna kowariancja, korelacja i semiwariancja | Założenia  Przestrzennej ciągłości - przestrzenna korelacja między zmienny w dwóch lokalizacjach zależy tylko od ich odległości (oraz czasem kierunku), lecz nie od tego gdzie są one położone Stacjonarności - średnia i wariancja są stałe na całym badanym obszarze    4.3.2 Przestrzenna kowariancja, korelacja i semiwariancja  \\(u\\) - wektor współrzędnych \\(z(u)\\) - badana zmienna jako funkcja położenia - inaczej określany jako ogon (ang. tail) \\(h\\) - lag - odstęp pomiędzy dwoma lokalizacjami \\(z(u+h)\\) - wartość badanej zmiennej odległej o odstęp \\(h\\) - inaczej określany jako głowa (ang. head)    4.3.3 Przestrzenna kowariancja, korelacja i semiwariancja  Kowariancja i korelacja to miary podobieństwa pomiędzy dwoma zmiennymi Przenosząc to na aspekt przestrzenny, badamy jedną zmienną ale pomiędzy dwoma punktami odległymi od siebie o pewien dystans (okreslany jako lag) W efekcie otrzymujemy miarę podobieństwa pomiędzy wartością głowy i ogona Trzecią miarę charakteryzującą relację między obserwacjami odległymi o kolejne odstępy jest semiwariancja Z praktycznego punktu widzenia, semiwariogram jest preferowaną miarą relacji przestrzennej, ponieważ wykazuje tendencję do lepszego wygładzania danych niż funkcja kowariancji Dodatkowo, semiwariogram jest mniej wymagający obliczeniowo Jednocześnie, dla potrzeb interpretacji relacji kowarancja i korelacja przestrzenna nadaje się nie gorzej niż semiwariancja     4.3.4 Wykres rozrzutu z przesunięciem hscat(temp~1, punkty, breaks=seq(0, 4000, by=500))    4.3.5 Autokowariancja  Autokowariancja pokazuje jak mocno są ze sobą powiązane przestrzennie wartości pary obserwacji odległych od siebie o kolejne przedziały  kowario &lt;- variogram(temp~1, punkty, covariogram = TRUE) plot(kowario)    4.3.6 Autokorelacja  Autokorelogram jest wykresem pokazującym jedną z miar autokorelacji (np. I Morana lub C Geary’ego) w stosunku do odległości  wsp &lt;- coordinates(punkty) kor &lt;- correlog(wsp, punkty$temp) kor &lt;- as.data.frame(kor) ggplot(kor, aes(dist.class, coef)) + geom_smooth(linetype=0) + geom_line() + geom_point(size=5)    4.3.7 Semiwariancja  Zmienność przestrzenna może być określona za pomocą semiwariancji. Jest to połowa średniej kwadratu różnicy pomiędzy wartościami badanej zmiennej w dwóch lokalizacjach odległych o wektor \\(h\\) \\[ \\gamma(h) = \\frac{1}{2}E[(z(s) - z(s+h))^2] \\]    4.3.8 Określenie występowania autokorelacji przestrzennej | Chmura semiwariogramu  Jeżeli w badanej próbie mamy \\(n\\) obserwacji oznacza to, że możemy zaobserwować \\(\\frac{1}{2}n(n-1)\\) par obserwacji Każda para obserwacji daje nam informacje o semiwariancji występującej wraz z odległością Semiwariancję można zaprezentować na wykresie zwanym chumrą semiwariogramu    4.3.9 Semiwariancja | Przykładowe obliczenia odl &lt;- dist(coordinates(punkty)[c(1, 2), ]) gamma &lt;- 0.5 * (punkty$temp[1] - punkty$temp[2])^2 gamma ## [1] 162.2628   4.3.10 Określenie występowania autokorelacji przestrzennej | Chmura semiwariogramu vario_cloud &lt;- variogram(temp~1, punkty, cloud=TRUE) plot(vario_cloud)     4.3.11 Określenie występowania autokorelacji przestrzennej | Chmura semiwariogramu vario_cloud_sel &lt;- plot(variogram(temp~1, punkty, cloud=TRUE), digitize=TRUE) plot(vario_cloud_sel, punkty)    4.3.12 Semiwariogram | Charakterystyka struktury przestrzennej  Semiwariogram to wykres pokazujący relację pomiędzy odległością a semiwariancją Jest to uśrednieniem semiwariancji dla kolejnych odstępów (lagów) W oparciu o semiwariogram empiryczny możemy następnie dopasować do niego model/e  \\[ \\hat{\\gamma}(h) = \\frac{1}{2N(h)}\\sum_{i=1}^{N(h)}(z(s_i) - z(s_i+h))^2 \\] gdzie \\(N(h)\\) oznacza liczbę par punktów w odstępie \\(h\\)   4.3.13 Semiwariogram  Nugget - efekt nuggetowy - pozwala na określenie błędu w danych wejściowych oraz zmienności na dystansie krótszym niż pierwszy odstęp Sill - semiwariancja progowa - oznacza wariancję badanej zmiennej Range - zasięg - to odległość do której istnieje przestrzenna korelacja    4.3.14 Semiwariogram | Rules of thumb  W każdym odstępie powinno się znaleźć co najmniej 30 par punktów Maksymalny zasięg semiwariogramu (ang. cutoff distance) to 1/2 pierwiastka z badanej powierzchni (inne źródła mówią o połowie z przekątnej badanego obszaru/jednej trzeciej) Liczba odstępów powinna nie być mniejsza niż 10 Optymalnie maksymalny zasięg semiwariogramu powinien być dłuższy o 10-15% od zasięgu zjawiska Optymalnie odstępy powinny być jak najbliżej siebie i jednocześnie nie być chaotyczne Warto metodą prób i błędów określić optymalne parametry semiwariogramu Należy określić czy zjawisko wykazuje anizotropię przestrzenną    4.3.15 Semiwariogram | Obliczenia pomocnicze  Liczba par obserwacji  0.5*length(punkty)*(length(punkty)-1) ## [1] 31626  Połowa pierwiastka powierzchni  pow &lt;- area(granica) as.vector(0.5*sqrt(pow)) ## [1] 3980.472  - Powierzchnia zajmowana przez jedną próbkę pow_pr &lt;- area(granica)/length(punkty) pow_pr ##        0  ## 251494.6  Średnia odległość między punktami  sqrt(pow_pr) ##        0  ## 501.4924   4.3.16 Semiwariogram | Maksymalny zasięg semiwariogramu (ang. Cutoff distance)  Maksymalny zasięg semiwariogramu (ang. Cutoff distance) jest domyślnie wyliczany w pakiecie gstat jako 1/3 z najdłuższej przekątnej badanego obszaru  vario_par &lt;- variogram(temp~1, punkty) vario_par ##      np      dist     gamma dir.hor dir.ver   id ## 1   131  218.6119  1.424513       0       0 var1 ## 2   312  490.7338  2.902181       0       0 var1 ## 3   516  797.7160  4.558657       0       0 var1 ## 4   683 1114.7117  4.659557       0       0 var1 ## 5   849 1433.5720  6.429404       0       0 var1 ## 6   965 1743.1558  7.539542       0       0 var1 ## 7  1103 2057.9031  7.622834       0       0 var1 ## 8  1246 2370.6101  8.663066       0       0 var1 ## 9  1219 2690.1356  9.657865       0       0 var1 ## 10 1343 3005.8324 10.384925       0       0 var1 ## 11 1377 3324.7716 11.179461       0       0 var1 ## 12 1432 3635.2805 11.959684       0       0 var1 ## 13 1485 3952.0183 13.396273       0       0 var1 ## 14 1494 4268.2314 14.485038       0       0 var1 ## 15 1478 4585.7878 15.256081       0       0 var1 plot(vario_par, plot.numbers=TRUE)  vario_par &lt;- variogram(temp~1, punkty, cutoff = 4000) plot(vario_par)    4.3.17 Semiwariogram | Odległość między przedziałami (ang. Interval width)  Domyślnie to maksymalny zasięg semiwariogramu podzielony przez 15 dahe odległość między przedziałami (ang. Interval width)  vario_par &lt;- variogram(temp~1, punkty, cutoff = 1000, width = 250) plot(vario_par)      4.4 Anizotropia  4.4.1 Anizotropia struktury przestrzennej  W wielu rzeczywistych sytuacjach, wartość cechy zależy nie tylko od odległości, ale także od kierunku    4.4.2 Mapa semiwariogramu  Mapa semiwariogramu (powierzchnia semiwariogramu) służy do określenia czy struktura przestrzenna zjawiska posiada anizotropię, a jeżeli tak to w jakim kierunku Na podstawie mapy semiwariogramu identyfikuje się parametry potrzebne do zbudowania semiwariogramów kierunkowych  vario_map &lt;- variogram(temp~1, punkty, cutoff=4000, width=400, map=TRUE) plot(vario_map, threshold=30) # co najmniej 30 par punktów    4.4.3 Mapa semiwariogramu | 3D plot3D(raster(vario_map$map), col=rainbow)   4.4.4 Semiwariogramy kierunkowe | Kierunki  W przypadku, gdy zjawisko wykazuje anizotropię przestrzenną, możliwe jest stworzenie semiwariogramów dla różnych wybranych kierunków Przykładowo, dla argumentu alpha = c(0, 45, 90, 135) cztery główne kierunki to 0, 45, 90 i 135 stopni. Oznacza to, że dla kierunku 45 stopni brane pod uwagę będą wszystkie pary punktów pomiędzy 22,5 a 67,5 stopnia.  vario_kier &lt;- variogram(temp~1, punkty, alpha = c(0, 45, 90, 135)) plot(vario_kier)    4.4.5 Semiwariogramy kierunkowe | Kierunki vario_kier &lt;- variogram(temp~1, punkty, alpha = c(60, 105, 150, 195)) plot(vario_kier)     "],
["modelowanie-matematycznie-autokorelacji-przestrzennej.html", "Rodział 5 Modelowanie matematycznie autokorelacji przestrzennej 5.1 Modele podstawowe 5.2 Metody modelowania 5.3 Modelowanie semiwariogramu 5.4 Modelowanie izotropowe 5.5 Modelowanie anizotropowe", " Rodział 5 Modelowanie matematycznie autokorelacji przestrzennej  5.0.1 Modelowanie matematycznie autokorelacji przestrzennej  Semiwariogram empiryczny jest:  Nieciągły - wartości semiwariancji są średnimi przedziałowymi Chaotyczny - badana próba jest jedynie przybliżeniem rzeczywistości, dodatkowo obciążonym błędami  Estymacje i symulacje przestrzenne wymagają modelu struktury przestrzennej analizowanej cechy, a nie tylko wartości empirycznych (wyliczonych z danych) Dodatkowo, matematycznie modelowanie wygładza chaotyczne fluktuacje danych empirycznych    5.1 Modele podstawowe  5.1.1 Modele podstawowe  Nuggetowy (ang. Nugget effect model) Sferyczny (ang. Spherical model) Gaussowski (ang. Gaussian model) Potęgowy (ang. Power model) Wykładniczy (ang. Exponential model) Inne  vgm() ##    short                                      long ## 1    Nug                              Nug (nugget) ## 2    Exp                         Exp (exponential) ## 3    Sph                           Sph (spherical) ## 4    Gau                            Gau (gaussian) ## 5    Exc               Exclass (Exponential class) ## 6    Mat                              Mat (Matern) ## 7    Ste Mat (Matern, M. Stein&#39;s parameterization) ## 8    Cir                            Cir (circular) ## 9    Lin                              Lin (linear) ## 10   Bes                              Bes (bessel) ## 11   Pen                      Pen (pentaspherical) ## 12   Per                            Per (periodic) ## 13   Wav                                Wav (wave) ## 14   Hol                                Hol (hole) ## 15   Log                         Log (logarithmic) ## 16   Pow                               Pow (power) ## 17   Spl                              Spl (spline) ## 18   Leg                            Leg (Legendre) ## 19   Err                   Err (Measurement error) ## 20   Int                           Int (Intercept) show.vgms()  show.vgms(models=c(&#39;Nug&#39;, &#39;Sph&#39;, &#39;Gau&#39;, &#39;Pow&#39;, &#39;Exp&#39;), range=1.4, max=2.5)  show.vgms(models=c(&#39;Nug&#39;, &#39;Sph&#39;, &#39;Gau&#39;, &#39;Pow&#39;, &#39;Exp&#39;), range=1.4, max=2.5, as.groups = TRUE)     5.2 Metody modelowania  5.2.1 Metody modelowania  Ustawianie “ręczne” parametrów modelu, np. funkcja vgm z pakietu gstat Ustawianie “wizualne” parametrów modelu, np. funkcja eyefit z pakietu geoR Automatyczny wybór parametrów na podstawie różnych kryterów statystycznych, np. funkcja fit.variogram z pakietu gstat, variofit z pakietu geoR, autofitVariogram z pakietu automap    5.2.2 Metody modelowania  Odpowiednie określenie modelu matematycznego często nie jest proste Automatyczne metody nie zawsze są w stanie dać lepszy wynik od modelowania “ręcznego” Najlepiej, gdy wybór modelu oparty jest o wiedzę na temat zakładanego procesu przestrzennego    5.2.3 Metody modelowania | Liniowy model regionalizacji  W przypadku, gdy analizowane zjawisko jest złożone, odwzorowanie kształtu semiwariogramu empirycznego wymaga połączenia dwóch lub większej liczby modeli podstawowych W takiej sytuacji konieczne jest spełnienie dwóch warunków:  Wszystkie zastosowane modele muszą być dopuszczalne (vgm()) Wariancja progowa każdego podstawowego modelu musi być dodatnia      5.3 Modelowanie semiwariogramu  5.3.1 Modelowanie semiwariogramu | funkcja fit.variogram  Funkcja fit.variogram dopasowuje zasięg oraz semiwariancję progową w oparciu o ustalone “ręcznie” parametry modelu      5.4 Modelowanie izotropowe  5.4.1 Modelowanie izotropowe | Modelowanie “wizualne” v_eye &lt;- eyefit(variog(as.geodata(punkty, &#39;temp&#39;))) ve_fit &lt;- as.vgm.variomodel(v_eye[[1]])   5.4.2 Modelowanie izotropowe | Model nuggetowy vario &lt;- variogram(temp~1, punkty) plot(vario)  model_nug &lt;- vgm(10, model = &#39;Nug&#39;) model_nug ##   model psill range ## 1   Nug    10     0 plot(vario, model=model_nug)  fitted_nug &lt;- fit.variogram(vario, model_nug) fitted_nug ##   model    psill range ## 1   Nug 4.356675     0 plot(vario, model=fitted_nug)    5.4.3 Modelowanie izotropowe | Model sferyczny vario &lt;- variogram(temp~1, punkty) plot(vario)  model_sph &lt;- vgm(psill=10, model = &#39;Sph&#39;, range=3000) model_sph ##   model psill range ## 1   Sph    10  3000 plot(vario, model=model_sph)  fitted_sph &lt;- fit.variogram(vario, model_sph) fitted_sph ##   model   psill    range ## 1   Sph 13.5325 4570.822 plot(vario, model=fitted_sph)    5.4.4 Modelowanie izotropowe | Model Gaussowski vario &lt;- variogram(temp~1, punkty) plot(vario)  model_gau &lt;- vgm(psill=15, model = &#39;Gau&#39;, range=3000) model_gau ##   model psill range ## 1   Gau    15  3000 plot(vario, model=model_gau)  fitted_gau &lt;- fit.variogram(vario, model_gau) fitted_gau ##   model    psill    range ## 1   Gau 8.361489 761.2621 plot(vario, model=fitted_gau)    5.4.5 Modelowanie izotropowe | Model potęgowy vario &lt;- variogram(temp~1, punkty) plot(vario)  model_pow &lt;- vgm(psill=1, model = &#39;Pow&#39;, range=0.30) model_pow ##   model psill range ## 1   Pow     1   0.3 plot(vario, model=model_pow)  fitted_pow &lt;- fit.variogram(vario, model_pow) fitted_pow ##   model      psill     range ## 1   Pow 0.02920527 0.7371518 plot(vario, model=fitted_pow)    5.4.6 Modelowanie izotropowe | Model wykładniczy vario &lt;- variogram(temp~1, punkty) plot(vario)  model_exp &lt;- vgm(psill=10, model = &#39;Exp&#39;, range=900) model_exp ##   model psill range ## 1   Exp    10   900 plot(vario, model=model_exp)  fitted_exp &lt;- fit.variogram(vario, model_exp) fitted_exp ##   model   psill    range ## 1   Exp 17.9672 3217.767 plot(vario, model=fitted_exp)    5.4.7 Modelowanie izotropowe | Modele złożone I vario &lt;- variogram(temp~1, punkty) model_zl1 &lt;- vgm(psill=10, model = &#39;Sph&#39;, range = 3000, add.to = vgm(0.5, &#39;Nug&#39;)) model_zl1 ##   model psill range ## 1   Nug   0.5     0 ## 2   Sph  10.0  3000 plot(vario, model=model_zl1)  fitted_zl1 &lt;- fit.variogram(vario, model_zl1) fitted_zl1 ##   model      psill    range ## 1   Nug  0.8981984    0.000 ## 2   Sph 14.8165152 6117.773 plot(vario, model=fitted_zl1)    5.4.8 Modelowanie izotropowe | Modele złożone II vario &lt;- variogram(temp~1, punkty) model_zl2 &lt;- vgm(2, &#39;Gau&#39;, 3000, add.to = vgm(8, model = &#39;Sph&#39;, range = 2000, nugget = 0.5)) model_zl2 ##   model psill range ## 1   Nug   0.5     0 ## 2   Sph   8.0  2000 ## 3   Gau   2.0  3000 plot(vario, model=model_zl2)  fitted_zl2 &lt;- fit.variogram(vario, model_zl2) plot(vario, model=fitted_zl2)     5.5 Modelowanie anizotropowe  5.5.1 Anizotropia  Uwzględnienie anizotropii wymaga zamiany parametru zasięgu na trzy inne parametry: Zasięg w dominującym kierunku Kąt określający dominujący kierunek Proporcję anizotropii, czyli relację pomiędzy zasięgiem w dominującym kierunku a zasięgiem w przeciwległym kierunku  vario_map &lt;- variogram(temp~1, punkty, cutoff=4000, width=400, map=TRUE) plot(vario_map)  vario_kier &lt;- variogram(temp~1, punkty, alpha = c(60, 105, 150, 195), cutoff=20000) plot(vario_kier, plot.numbers=TRUE)  vario_kier_fit &lt;- vgm(psill=8, model=&#39;Sph&#39;, range=4000, nugget=0.5, anis = c(60, .4)) plot(vario_kier, vario_kier_fit, as.table=TRUE)     "],
["estymacje-jednozmienne.html", "Rodział 6 Estymacje jednozmienne 6.1 Kriging 6.2 Rodzaje krigingu 6.3 Kriging prosty (ang. Simple kriging) 6.4 Kriging zwykły (ang. Ordinary kriging) 6.5 Porównanie wyników SK, OK i KZT", " Rodział 6 Estymacje jednozmienne  6.1 Kriging  6.1.1 Kriging | Interpolacja geostatystyczna  Zaproponowana w latach 50. przez Daniela Krige Istnieje wiele rodzajów krigingu Główna zasada mówi, że prognoza w danej lokalizacji jest kombinacją obokległych obserwacji Waga nadawana każdej z obserwacji jest zależna od stopnia (przestrzennej) korelacji - stąd też bierze się istotna rola semiwariogramów     6.2 Rodzaje krigingu  6.2.1 Rodzaje krigingu  Kriging prosty (ang. Simple kriging) Kriging zwykły (ang. Ordinary kriging) Kriging z trendem (ang. Kriging with a trend) Kriging danych kodowanych (ang. Indicator kriging) Kriging stratyfikowany (ang. Kriging within strata – KWS) Kriging prosty ze zmiennymi średnimi lokalnymi (ang. Simple kriging with varying local means - SKlm) Kriging z zewnętrznym trendem/Uniwersalny kriging (ang.Kriging with an external trend/Universal kriging) Kokriging (ang. Co-kriging) Inne     6.3 Kriging prosty (ang. Simple kriging)  6.3.1 Kriging prosty (ang. Simple kriging)  Zakłada, że średnia jest znana i stała na całym obszarze    6.3.2 Kriging prosty (ang. Simple kriging) ras &lt;- raster(&#39;dane/siatka.tif&#39;) grid &lt;- as(ras, &#39;SpatialGridDataFrame&#39;) proj4string(grid) &lt;- proj4string(punkty)  vario &lt;- variogram(temp~1, punkty) model &lt;- vgm(10, model = &#39;Sph&#39;, range = 4000, nugget = 0.5) model ##   model psill range ## 1   Nug   0.5     0 ## 2   Sph  10.0  4000 fitted &lt;- fit.variogram(vario, model) plot(vario, model=fitted)  sk &lt;- krige(temp~1, punkty, grid, model=fitted, beta=15.324) ## [using simple kriging] summary(sk) ## Object of class SpatialGridDataFrame ## Coordinates: ##         min      max ## s1 745541.7 756971.7 ## s2 712616.2 721256.2 ## Is projected: TRUE  ## proj4string : ## [+init=epsg:2180 +proj=tmerc +lat_0=0 +lon_0=19 +k=0.9993 ## +x_0=500000 +y_0=-5300000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 ## +units=m +no_defs] ## Grid attributes: ##    cellcentre.offset cellsize cells.dim ## s1          745586.7       90       127 ## s2          712661.2       90        96 ## Data attributes: ##    var1.pred         var1.var     ##  Min.   : 8.606   Min.   :1.365   ##  1st Qu.:12.917   1st Qu.:2.099   ##  Median :15.020   Median :2.410   ##  Mean   :15.661   Mean   :2.495   ##  3rd Qu.:17.873   3rd Qu.:2.805   ##  Max.   :25.938   Max.   :5.266   ##  NA&#39;s   :1242     NA&#39;s   :1242 spplot(sk, &#39;var1.pred&#39;) spplot(sk, &#39;var1.var&#39;)     6.4 Kriging zwykły (ang. Ordinary kriging)  6.4.1 Kriging zwykły (ang. Ordinary kriging)  Średnia traktowana jest jako nieznana Uwzględnia lokalne fluktuacje średniej poprzez stosowanie ruchomego okna    6.4.2 Kriging zwykły (ang. Ordinary kriging) ok &lt;- krige(temp~1, punkty, grid, model=fitted, maxdist=1000) ## [using ordinary kriging] # ok &lt;- krige(temp~1, punkty, grid, model=fitted, nmax=30) spplot(ok, &#39;var1.pred&#39;) spplot(ok, &#39;var1.var&#39;)   spplot(ok, &quot;var1.var&quot;, sp.layout=list(punkty, pch=21, col=&quot;white&quot;))  –&gt; ## Kriging z trendem (ang. Kriging with a trend) ### Kriging z trendem (ang. Kriging with a trend) vario_kzt &lt;- variogram(temp~x+y, data=punkty) plot(vario_kzt)  model_kzt &lt;- vgm(psill = 5, model = &#39;Sph&#39;, range = 2500, nugget = 1) fitted_kzt &lt;- fit.variogram(vario_kzt, model_kzt) fitted_kzt ##   model     psill range ## 1   Nug 0.4470857     0 ## 2   Sph 6.5817020  2052 plot(vario_kzt, fitted_kzt)  grid_sp &lt;- as(ras, &#39;SpatialPixelsDataFrame&#39;) proj4string(grid_sp) &lt;- proj4string(punkty) grid_sp@data &lt;- as.data.frame(coordinates(grid_sp))  punkty@data &lt;- cbind(punkty@data, as.data.frame(coordinates(punkty))) kzt &lt;- krige(temp~x+y, punkty, grid_sp, model=fitted_kzt) ## [using universal kriging] spplot(kzt, &#39;var1.pred&#39;) spplot(kzt, &#39;var1.var&#39;)     6.5 Porównanie wyników SK, OK i KZT    "],
["ocena-jakosci-estymacji-uwaga-pomieszany-me-z-reszta.html", "Rodział 7 Ocena jakości estymacji [UWAGA POMIESZANY ME Z RESZTĄ!!] 7.1 Statystyki jakości estymacji 7.2 Walidacja wyników estymacji", " Rodział 7 Ocena jakości estymacji [UWAGA POMIESZANY ME Z RESZTĄ!!]  7.1 Statystyki jakości estymacji  7.1.1 Statystyki jakości estymacji  Służą do oceny i porównania jakości estymacji Do podstawowych statystyk ocen jakości estymacji należą:  Średni błąd estymacji (ME, ang. mean error) Pierwiastek średniego błędu kwadratowego (RMSE, ang. root square prediction error) Współczynnik korelacji Rozkład błędu (np. 5. percentyl, mediana, 95. percentyl)     7.1.2 Statystyki jakości estymacji  Idealna estymacja dawałaby brak błędu oraz wspołczynnik korelacji pomiędzy pomiarami (całą populacją) i szacunkiem równy 1 Wysokie, pojedyncze wartości błędu mogą świadczyć, np. o wystapieniu wartości odstających    7.1.3 Średni błąd estymacji  Optymalnie wartość średniego błędu estymacji powinna być jak najbliżej 0  \\[ ME=\\frac{\\sum_{i=1}^{n}(\\hat{v}_i-v_i)}{n} \\] ### Pierwiastek średniego błędu kwadratowego - Optymalnie wartość pierwiastka średniego błędu kwadratowego powinna być jak najmniejsza \\[ RMSE=\\sqrt{\\frac{\\sum_{i=1}^{n}(\\hat{v}_i-v_i)^2}{n}} \\]   7.1.4 Współczynnik korelacji  Optymalnie wartość współczynnika korelacji powinna być jak najwyższa    7.1.5 Statystyki jakości estymacji | Mapa ## [using simple kriging]    7.1.6 Statystyki jakości estymacji | Histogram    7.1.7 Statystyki jakości estymacji | Wykres rozrzutu     7.2 Walidacja wyników estymacji  7.2.1 Walidacja wyników estymacji  Dokładne dopasowanie modelu do danych może w efekcie nie dawać najlepszych wyników W efekcie ważne jest stosowanie metod pozwalających na wybranie optymalnego modelu Do takich metod należy, między innymi, walidacja podzbiorem (ang. jackknifing) oraz kroswalidacja (ang. crossvalidation)    7.2.2 Walidacja podzbiorem  Polega na podziale zbioru danych na dwa podzbiory - treningowy i testowy Zbiór treningowy służy do estymacji wartości Wynik estymacji porównywany jest z rzeczywistymi wartościami ze zbioru testowego Zaletą tego podejścia jest stosowanie danych niezależnych od estymacji Wadą jest konieczność posiadania dużego zbioru danych    7.2.3 Walidacja podzbiorem set.seed(124) indeks &lt;- as.vector(createDataPartition(punkty$temp, p=0.75, list=FALSE)) indeks ##   [1]   2   3   5   6   7   8  11  12  13  14  15  16  18  19  20  21  22 ##  [18]  24  25  26  28  30  31  32  34  35  36  38  40  41  42  46  48  49 ##  [35]  50  53  55  58  61  63  64  66  68  69  71  72  73  74  75  76  78 ##  [52]  79  81  82  83  84  86  87  88  89  90  91  92  93  95  96  97  98 ##  [69]  99 100 101 102 103 104 105 106 107 108 109 110 111 113 114 115 117 ##  [86] 119 120 122 123 124 126 127 128 129 131 132 133 134 135 136 138 139 ## [103] 141 142 143 144 145 146 147 148 150 151 153 156 157 158 159 161 162 ## [120] 163 164 165 166 167 168 169 170 171 173 174 176 178 180 181 182 183 ## [137] 184 185 186 187 189 190 191 192 193 194 195 196 198 199 201 202 203 ## [154] 204 206 207 210 211 213 214 215 216 217 218 219 221 222 223 225 227 ## [171] 228 229 230 231 232 233 234 235 236 237 238 240 241 242 243 244 245 ## [188] 246 248 249 250 251 train &lt;- punkty[indeks, ] test &lt;- punkty[-indeks, ] vario &lt;- variogram(temp~1, data=train) model &lt;- vgm(10, model = &#39;Sph&#39;, range = 4000, nugget = 0.5) fitted &lt;- fit.variogram(vario, model) plot(vario, model=fitted)  test_sk &lt;- krige(temp~1, train, test, model=fitted, beta=15.324) ## [using simple kriging] summary(test_sk) ## Object of class SpatialPointsDataFrame ## Coordinates: ##        min      max ## x 745947.9 756963.6 ## y 712721.8 720961.5 ## Is projected: TRUE  ## proj4string : ## [+init=epsg:2180 +proj=tmerc +lat_0=0 +lon_0=19 +k=0.9993 ## +x_0=500000 +y_0=-5300000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 ## +units=m +no_defs] ## Number of points: 60 ## Data attributes: ##    var1.pred         var1.var     ##  Min.   : 9.557   Min.   :1.767   ##  1st Qu.:12.603   1st Qu.:2.251   ##  Median :15.391   Median :2.612   ##  Mean   :15.634   Mean   :2.696   ##  3rd Qu.:17.426   3rd Qu.:3.097   ##  Max.   :24.848   Max.   :4.622 reszta_sk &lt;-  test_sk$var1.pred - test$temp summary(reszta_sk) ##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  ## -5.1500 -0.6094  0.2412  0.1428  0.8380  3.9580 ME &lt;- sum(reszta_sk)/length(reszta_sk) ME ## [1] 0.1427624 RMSE &lt;- sqrt(sum(reszta_sk^2)/length(reszta_sk)) RMSE ## [1] 1.553077 srednia_reszta &lt;- test$temp - mean(test$temp) R2 &lt;- 1 - sum(reszta_sk^2)/sum(srednia_reszta^2) R2 ## [1] 0.8579729 test_sk$reszty &lt;- reszta_sk spplot(test_sk, &#39;reszty&#39;)    7.2.4 Kroswalidacja  W przypadku kroswalidacji te same dane wykorzystywane są do budowy modelu, estymacji, a następnie do oceny prognozy Procedura kroswalidacji LOO (ang. leave-one-out cross-validation)   Zbudowanie matematycznego modelu z dostępnych obserwacji Dla każdej znanej obserwacji następuje:  Usunięcie jej ze zbioru danych Użycie modelu do wykonania predykcji w miejscu tej obserwacji Wyliczenie reszty (ang. residual), czyli różnicy pomiędzy znaną wartością a obserwacją  Podsumowanie otrzymanych wyników   W pakiecie gstat, kroswalidacja LOO jest dostępna w funkcjach krige.cv oraz gstat.cv    7.2.5 Kroswalidacja vario &lt;- variogram(temp~1, data=punkty) model &lt;- vgm(10, model = &#39;Sph&#39;, range = 4000, nugget = 0.5) fitted &lt;- fit.variogram(vario, model)  cv_sk &lt;- krige.cv(temp~1, punkty, model=fitted, beta=15.324) summary(cv_sk) ## Object of class SpatialPointsDataFrame ## Coordinates: ##        min      max ## x 745619.3 756963.6 ## y 712664.4 721253.9 ## Is projected: NA  ## proj4string : [NA] ## Number of points: 252 ## Data attributes: ##    var1.pred         var1.var        observed         residual        ##  Min.   : 8.975   Min.   :1.593   Min.   : 8.153   Min.   :-5.47105   ##  1st Qu.:12.482   1st Qu.:2.016   1st Qu.:12.459   1st Qu.:-0.83011   ##  Median :15.102   Median :2.325   Median :15.210   Median :-0.12253   ##  Mean   :15.546   Mean   :2.477   Mean   :15.522   Mean   :-0.02396   ##  3rd Qu.:17.743   3rd Qu.:2.760   3rd Qu.:18.258   3rd Qu.: 0.85718   ##  Max.   :25.531   Max.   :7.124   Max.   :26.700   Max.   : 4.91660   ##      zscore               fold        ##  Min.   :-3.641395   Min.   :  1.00   ##  1st Qu.:-0.554410   1st Qu.: 63.75   ##  Median :-0.083264   Median :126.50   ##  Mean   :-0.003519   Mean   :126.50   ##  3rd Qu.: 0.597911   3rd Qu.:189.25   ##  Max.   : 2.890799   Max.   :252.00 spplot(cv_sk, &#39;residual&#39;)      "],
["estymacja-lokalnego-rozkadu-prawdopodobienstwa.html", "Rodział 8 Estymacja lokalnego rozkładu prawdopodobieństwa 8.1 Kriging danych kodowanych (ang. Indicator kriging) | Wprowadzenie 8.2 Kriging danych kodowanych (ang. Indicator kriging) | Przykłady", " Rodział 8 Estymacja lokalnego rozkładu prawdopodobieństwa  8.1 Kriging danych kodowanych (ang. Indicator kriging) | Wprowadzenie  8.1.1 Kriging danych kodowanych (ang. Indicator kriging)  Jest to metoda krigingu oparta o dane kategoryzowane lub też dane przetworzone z postaci ciągłej do binarnej Zazwyczaj używana jest to oszacowania prawdopodobieństwa przekroczenia zdefiniowanej wartości progowej Może być też używana do szacowania wartości z całego rozkładu     8.1.2 Kriging danych kodowanych (ang. Indicator kriging)  Wartości danych wykorzystywane do krigingu danych kodowanych są określone jako 0 lub 1 Powyzsze kategorie reprezentują czy wartość danej zmiennej jest powyżej czy poniżej określonego progu    8.1.3 Kriging danych kodowanych (ang. Indicator kriging)| Wady i zalety  Zalety:  Możliwość zastosowania, gdy nie interesuje nas konkretna wartość, ale znalezienie obszarów o wartości przekraczającej dany poziom Nie jest istotny kszałt rozkładu  Wady:  Potencjalnie trudne do modelowania semiwariogramy (szczególnie skrajnych przedziałów) Czasochłonność/pracochłonność      8.2 Kriging danych kodowanych (ang. Indicator kriging) | Przykłady  8.2.1 Binaryzacja danych summary(punkty$temp)  ##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  ##   8.153  12.460  15.210  15.520  18.260  26.700 punkty$temp_ind &lt;- punkty$temp &gt; 20 summary(punkty$temp_ind)  ##    Mode   FALSE    TRUE    NA&#39;s  ## logical     212      40       0   8.2.2 Eksploracja danych ggplot(punkty@data, aes(temp)) + stat_ecdf()    8.2.3 Kriging danych kodowanych (ang. Indicator kriging) | Semiwariogram vario_ind &lt;- variogram(temp_ind~1, punkty)          plot(vario_ind)    8.2.4 Kriging danych kodowanych (ang. Indicator kriging) | Modelowanie model_ind &lt;- vgm(0.07, model = &#39;Sph&#39;, range = 3000,  nugget = 0.01)   plot(vario_ind, model=model_ind)  fitted_ind &lt;- fit.variogram(vario_ind, model_ind) fitted_ind ##   model      psill    range ## 1   Nug 0.01303201    0.000 ## 2   Sph 0.09822073 4710.163 plot(vario_ind, model=fitted_ind)    8.2.5 Kriging danych kodowanych (ang. Indicator kriging) | Interpolacja ik &lt;- krige(temp_ind~1, punkty, grid, model=fitted_ind) ## [using ordinary kriging] spplot(ik, &#39;var1.pred&#39;) spplot(ik, &#39;var1.var&#39;)    8.2.6 Kriging danych kodowanych (ang. Indicator kriging) vario_ind20 &lt;- variogram(I(temp&lt;20)~1, punkty)   fitted_ind20 &lt;- fit.variogram(vario_ind20, vgm(0.08, &#39;Sph&#39;, 3500, nugget=0.01)) vario_ind16 &lt;- variogram(I(temp&lt;16)~1, punkty)   fitted_ind16 &lt;- fit.variogram(vario_ind16, vgm(0.18, &#39;Sph&#39;, 3500, nugget=0.03)) vario_ind12 &lt;- variogram(I(temp&lt;12)~1, punkty)   fitted_ind12 &lt;- fit.variogram(vario_ind12, vgm(0.13, &#39;Sph&#39;, 2000, nugget=0.03))  ik20 &lt;- krige(I(temp&lt;20)~1, punkty, grid, model=fitted_ind20, nmax=30) ## [using ordinary kriging] ik16 &lt;- krige(I(temp&lt;16)~1, punkty, grid, model=fitted_ind16, nmax=30) ## [using ordinary kriging] ik12 &lt;- krige(I(temp&lt;12)~1, punkty, grid, model=fitted_ind12, nmax=30) ## [using ordinary kriging]     "],
["estymacje-wielozmienne.html", "Rodział 9 Estymacje wielozmienne 9.1 Kokriging (prosty i zwykły, SCK i OCK) 9.2 Krossemiwariogramy 9.3 Modelowanie krossemiwariogramów 9.4 Kokriging", " Rodział 9 Estymacje wielozmienne  9.1 Kokriging (prosty i zwykły, SCK i OCK)  9.1.1 Kokriging (ang. co-kriging)  Kokriging pozwala na wykorzystanie dodatkowej zmiennej (ang. auxiliary variable), zwanej inaczej kozmienną (ang. co-variable), która może być użyta do prognozwania wartości badanej zmiennej w nieopróbowanej lokalizacji Zmienna dodatkowa może być pomierzona w tych samych miejscach, gdzie badana zmienna, jak też w innych niż badana zmienna Możliwa jest też sytuacja, gdy zmienna dodatkowa jest pomierzona w dwóch powyższych przypadkach Kokriging wymaga, aby obie zmienne były istotnie ze sobą skorelowane Najczęściej kokriging jest stosowany w sytuacji, gdy zmienna dodatkowa jest łatwiejsza (tańsza) do pomierzenia niż zmienna główna W efekcie, uzyskany zbiór danych zawiera informacje o badanej zmiennej oraz gęściej opróbowane informacje o zmiennej dodatkowej Jeżeli informacje o zmiennej dodatkowej są znane dla całego obszaru wówczas bardziej odpowiednią techniką będzie kriging z zewnątrznym trendem (KED)    9.1.2 Kokriging | Wybór dodatkowej zmiennej  Wybór zmiennej dodatkowej może opierać się na dwóch kryteriach:  Teoretycznym Empirycznym       9.2 Krossemiwariogramy  9.2.1 Krossemiwariogramy  Krossemiwariogram jest to wariancja różnicy pomiędzy dwiema zmiennymi w dwóch lokalizacjach Wyliczając Krossemiwariogram otrzymujemy empiryczne semiwatiogramy dla dwóch badanych zmiennych oraz kroswariogram dla kombinacji dwóch zmiennych Krossemiwariogram znajduje swoje zastosowanie w technice zwanej kokrigingiem    9.2.2 Krossemiwariogramy punkty &lt;- read.csv(&#39;dane/punkty.csv&#39;) coordinates(punkty) &lt;- ~x+y proj4string(punkty) &lt;- &#39;+init=epsg:2180&#39;  punkty_ndvi &lt;- read.csv(&#39;dane/punkty_ndvi.csv&#39;) coordinates(punkty_ndvi) &lt;- ~x+y proj4string(punkty_ndvi) &lt;- &#39;+init=epsg:2180&#39;  g &lt;- gstat(NULL, id=&#39;SAVI&#39;, form = savi~1, data = punkty) g &lt;- gstat(g, id=&#39;NDVI&#39;, form = ndvi~1, data = punkty_ndvi) g ## data: ## SAVI : formula = savi`~`1 ; data dim = 252 x 5 ## NDVI : formula = ndvi`~`1 ; data dim = 1011 x 1 v &lt;- variogram(g) plot(v)     9.3 Modelowanie krossemiwariogramów  9.3.1 Modelowanie krossemiwariogramów | fit.lmc  Funkcja fit.lmc dopasowuje liniowy model koregionalizacji do semiwariogramów wielozmienych    9.3.2 Modelowanie krossemiwariogramów g &lt;- gstat(g, model=vgm(0.006, &#39;Sph&#39;, 2000, 0.001), fill.all=TRUE) g_fit &lt;- fit.lmc(v, g) g_fit ## data: ## SAVI : formula = savi`~`1 ; data dim = 252 x 5 ## NDVI : formula = ndvi`~`1 ; data dim = 1011 x 1 ## variograms: ##              model       psill range ## SAVI[1]        Nug 0.002841025     0 ## SAVI[2]        Sph 0.004263643  2000 ## NDVI[1]        Nug 0.003120480     0 ## NDVI[2]        Sph 0.006335148  2000 ## SAVI.NDVI[1]   Nug 0.002977476     0 ## SAVI.NDVI[2]   Sph 0.004962607  2000 plot(v, g_fit)      9.4 Kokriging  9.4.1 Kokriging ck &lt;- predict(g_fit, grid)  ## Linear Model of Coregionalization found. Good. ## [using ordinary cokriging] summary(ck) ## Object of class SpatialGridDataFrame ## Coordinates: ##         min      max ## s1 745541.7 756971.7 ## s2 712616.2 721256.2 ## Is projected: TRUE  ## proj4string : ## [+init=epsg:2180 +proj=tmerc +lat_0=0 +lon_0=19 +k=0.9993 ## +x_0=500000 +y_0=-5300000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 ## +units=m +no_defs] ## Grid attributes: ##    cellcentre.offset cellsize cells.dim ## s1          745586.7       90       127 ## s2          712661.2       90        96 ## Data attributes: ##    SAVI.pred         SAVI.var        NDVI.pred         NDVI.var      ##  Min.   :0.1092   Min.   :0.0034   Min.   :0.2284   Min.   :0.0037   ##  1st Qu.:0.2903   1st Qu.:0.0038   1st Qu.:0.4713   1st Qu.:0.0043   ##  Median :0.3166   Median :0.0039   Median :0.5051   Median :0.0044   ##  Mean   :0.3131   Mean   :0.0039   Mean   :0.5008   Mean   :0.0045   ##  3rd Qu.:0.3438   3rd Qu.:0.0040   3rd Qu.:0.5406   3rd Qu.:0.0046   ##  Max.   :0.4055   Max.   :0.0051   Max.   :0.6260   Max.   :0.0063   ##  NA&#39;s   :1242     NA&#39;s   :1242     NA&#39;s   :1242     NA&#39;s   :1242     ##  cov.SAVI.NDVI    ##  Min.   :0.0034   ##  1st Qu.:0.0038   ##  Median :0.0040   ##  Mean   :0.0040   ##  3rd Qu.:0.0041   ##  Max.   :0.0054   ##  NA&#39;s   :1242 spplot(ck, &#39;SAVI.pred&#39;) spplot(ck, &#39;SAVI.var&#39;)     "],
["wykorzystanie-do-estymacji-danych-uzupeniajacych.html", "Rodział 10 Wykorzystanie do estymacji danych uzupełniających 10.1 Kriging stratyfikowany (ang. Kriging within strata) 10.2 Prosty kriging ze zmiennymi średnimi lokalnymi (LVM) 10.3 Kriging uniwersalny (ang. Universal kriging)", " Rodział 10 Wykorzystanie do estymacji danych uzupełniających  10.1 Kriging stratyfikowany (ang. Kriging within strata)  10.1.1 Kriging stratyfikowany (ang. Kriging within strata)  Zakłada on, że zmienność badanego zjawiska zależy od zmiennej jakościowej (kategoryzowanej) Przykładowo, zróżnicowanie badanej zmiennej jest różne w zależności od pokrycia terenu Kriging stratyfikowany wymaga posiadania danych zmiennej jakościowej (kategoryzowanej) na całym badanym obszarze    10.1.2 Kriging stratyfikowany (ang. Kriging within strata) grid &lt;- read.csv(&#39;dane/siatka.csv&#39;) head(grid) ##       srtm clc      ndvi      savi        x        y ## 1       NA  NA 0.5179814 0.3308685 748826.7 721211.2 ## 2 240.9517   1 0.5275287 0.3408735 748916.7 721211.2 ## 3 238.6385   1 0.5066541 0.3252446 749006.7 721211.2 ## 4 237.6719   1 0.5220953 0.3370855 749096.7 721211.2 ## 5 235.7462   1 0.5240265 0.3384357 749186.7 721211.2 ## 6 230.6863   1 0.6171365 0.4051174 749276.7 721211.2 coordinates(grid) &lt;- ~x+y proj4string(grid) &lt;- proj4string(punkty) gridded(grid) &lt;- TRUE  grid$clc &lt;- as.factor(grid$clc) spplot(grid, &#39;clc&#39;)  vario_kws1 &lt;- variogram(temp~1, punkty[punkty$clc==1, ]) plot(vario_kws1)  fitted_kws1 &lt;- fit.variogram(vario_kws1, vgm(10, model = &#39;Sph&#39;, range = 4500, nugget = 0.5)) plot(vario_kws1, fitted_kws1)  vario_kws2 &lt;- variogram(temp~1, punkty[punkty$clc==2, ]) plot(vario_kws2)  fitted_kws2 &lt;- fit.variogram(vario_kws2, vgm(5, model = &#39;Sph&#39;, range = 4500, nugget = 0.1)) plot(vario_kws2, fitted_kws2)  vario_kws4 &lt;- variogram(temp~1, punkty[punkty$clc==4, ]) plot(vario_kws4)  fitted_kws4 &lt;- fit.variogram(vario_kws4, vgm(0.5, model = &#39;Nug&#39;)) plot(vario_kws4, fitted_kws4)  kws1 &lt;- krige(temp~1, punkty[punkty$clc==1, ], grid[na.omit(grid$clc==1), ], model = fitted_kws1, nmax = 50) ## [using ordinary kriging] kws2 &lt;- krige(temp~1, punkty[punkty$clc==2, ], grid[na.omit(grid$clc==2), ], model = fitted_kws2, nmax = 50) ## [using ordinary kriging] kws4 &lt;- krige(temp~1, punkty[punkty$clc==4, ], grid[na.omit(grid$clc==4), ], model = fitted_kws4, nmax = 50) ## [using ordinary kriging] kws &lt;- rbind(as.data.frame(kws1), as.data.frame(kws2), as.data.frame(kws4)) coordinates(kws) &lt;- ~x+y kws &lt;- as(kws, &#39;SpatialPixelsDataFrame&#39;) spplot(kws, &#39;var1.pred&#39;, sp.layout=(list=SpatialPoints(punkty)))     10.2 Prosty kriging ze zmiennymi średnimi lokalnymi (LVM)  10.2.1 Prosty kriging ze zmiennymi średnimi lokalnymi (LVM)  Prosty kriging ze zmiennymi średnimi lokalnymi zamiast znanej (stałej) stacjonarnej średniej wykorzystuje zmienne średnie lokalne uzyskane na podstawie innej informacji Lokalna średnia może być uzyskana za pomocą wyliczenia regresji liniowej pomiędzy zmienną badaną a zmienną dodatkową    10.2.2 Prosty kriging ze zmiennymi średnimi lokalnymi (LVM) coef &lt;- lm(temp~srtm, punkty)$coef coef ##  (Intercept)         srtm  ## 16.480355788 -0.004535255 vario &lt;- variogram(temp~srtm, punkty) model_sim &lt;- vgm(10, model = &#39;Sph&#39;, range = 4000, nugget = 1) model_sim ##   model psill range ## 1   Nug     1     0 ## 2   Sph    10  4000 fitted_sim &lt;- fit.variogram(vario, model_sim) fitted_sim ##   model      psill    range ## 1   Nug  0.9382992    0.000 ## 2   Sph 14.5761601 6027.977 plot(vario, model=fitted_sim)  sk_lvm &lt;- krige(temp~srtm, punkty, grid, model=fitted_sim, beta = coef) ## [using simple kriging] summary(sk_lvm) ## Object of class SpatialPixelsDataFrame ## Coordinates: ##        min      max ## x 745586.7 756926.7 ## y 712661.2 721211.2 ## Is projected: TRUE  ## proj4string : ## [+init=epsg:2180 +proj=tmerc +lat_0=0 +lon_0=19 +k=0.9993 ## +x_0=500000 +y_0=-5300000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 ## +units=m +no_defs] ## Number of points: 10993 ## Grid attributes: ##   cellcentre.offset cellsize cells.dim ## x          745586.7       90       127 ## y          712661.2       90        96 ## Data attributes: ##    var1.pred         var1.var     ##  Min.   : 8.624   Min.   :1.415   ##  1st Qu.:12.942   1st Qu.:2.148   ##  Median :15.037   Median :2.458   ##  Mean   :15.666   Mean   :2.543   ##  3rd Qu.:17.875   3rd Qu.:2.853   ##  Max.   :25.922   Max.   :5.313   ##  NA&#39;s   :43       NA&#39;s   :43 spplot(sk_lvm, &#39;var1.pred&#39;) spplot(sk_lvm, &#39;var1.var&#39;)     10.3 Kriging uniwersalny (ang. Universal kriging)  10.3.1 Kriging uniwersalny (ang. Universal kriging)  Określany również jako kriging z trendem (ang. Kriging with a trend model) Zakłada on, że nieznana średnia lokalna zmiania się stopniowo na badanym obszarze    10.3.2 Kriging uniwersalny (ang. Universal kriging)  punkty$clc &lt;- as.factor(punkty$clc) vario_uk1 &lt;- variogram(temp~clc, punkty) vario_uk1 ##      np      dist    gamma dir.hor dir.ver   id ## 1   131  218.6119 1.492195       0       0 var1 ## 2   312  490.7338 2.692324       0       0 var1 ## 3   516  797.7160 4.143141       0       0 var1 ## 4   683 1114.7117 4.032339       0       0 var1 ## 5   849 1433.5720 4.422906       0       0 var1 ## 6   965 1743.1558 5.112034       0       0 var1 ## 7  1103 2057.9031 5.212272       0       0 var1 ## 8  1246 2370.6101 5.790961       0       0 var1 ## 9  1219 2690.1356 6.934307       0       0 var1 ## 10 1343 3005.8324 7.179945       0       0 var1 ## 11 1377 3324.7716 7.685214       0       0 var1 ## 12 1432 3635.2805 7.885347       0       0 var1 ## 13 1485 3952.0183 8.361701       0       0 var1 ## 14 1494 4268.2314 9.018930       0       0 var1 ## 15 1478 4585.7878 9.241991       0       0 var1 plot(vario_uk1)  model_uk1 &lt;- vgm(8, model = &#39;Sph&#39;, range = 3000, nugget = 1) vario_fit_uk1 &lt;- fit.variogram(vario_uk1, model=model_uk1) vario_fit_uk1 ##   model    psill    range ## 1   Nug 1.292171    0.000 ## 2   Sph 7.441007 4763.345 plot(vario_uk1, vario_fit_uk1)   grid$clc &lt;- as.factor(grid$clc) spplot(grid, &#39;clc&#39;)  uk1 &lt;- krige(temp~clc, locations = punkty, newdata=grid, model=vario_fit_uk1) ## [using universal kriging] spplot(uk1, &#39;var1.pred&#39;) spplot(uk1, &#39;var1.var&#39;)  vario_uk2 &lt;- variogram(temp~ndvi+srtm, punkty) vario_uk2 ##      np      dist     gamma dir.hor dir.ver   id ## 1   131  218.6119  1.386828       0       0 var1 ## 2   312  490.7338  2.822672       0       0 var1 ## 3   516  797.7160  4.294554       0       0 var1 ## 4   683 1114.7117  4.501500       0       0 var1 ## 5   849 1433.5720  6.310286       0       0 var1 ## 6   965 1743.1558  7.395085       0       0 var1 ## 7  1103 2057.9031  7.375078       0       0 var1 ## 8  1246 2370.6101  8.529375       0       0 var1 ## 9  1219 2690.1356  9.517366       0       0 var1 ## 10 1343 3005.8324 10.213423       0       0 var1 ## 11 1377 3324.7716 11.100148       0       0 var1 ## 12 1432 3635.2805 11.730141       0       0 var1 ## 13 1485 3952.0183 13.053957       0       0 var1 ## 14 1494 4268.2314 14.252817       0       0 var1 ## 15 1478 4585.7878 14.968739       0       0 var1 plot(vario_uk2)  model &lt;- vgm(8, model = &#39;Sph&#39;, range = 3000, nugget = 1) vario_fit_uk2 &lt;- fit.variogram(vario_uk2, model=model) vario_fit_uk2 ##   model      psill    range ## 1   Nug  0.8470453    0.000 ## 2   Sph 14.8073531 6243.382 plot(vario_uk2, vario_fit_uk2)  uk2 &lt;- krige(temp~ndvi+srtm, locations = punkty, newdata=grid, model=vario_fit_uk2) ## [using universal kriging] spplot(uk2, &#39;var1.pred&#39;) spplot(uk2, &#39;var1.var&#39;)     "],
["symulacje.html", "Rodział 11 Symulacje 11.1 Symulacje geostatystyczne 11.2 Typy symulacji 11.3 Symulacje bezwarunkowe 11.4 Symulacje warunkowe 11.5 Sekwencyjna symulacja danych kodowanych (ang. Sequential indicator simulation)", " Rodział 11 Symulacje   11.1 Symulacje geostatystyczne  11.1.1 Symulacje geostatystyczne  Kriging daje optymalne predykcje, czyli wyznacza najbardziej potencjalnie możliwą wartość dla wybranej lokalizacji Dodatkowo, efektem krigingu jest wygładzony obraz. W konsekwencji wyniki estymacji różnią się od danych pomiarowych Jest to tylko (aż?) predykcja. Prawdziwa wartość jest niepewna … Korzystając z symulacji geostatystycznych nie tworzymy predykcji, ale generujemy równie prawdopodobne możliwości poprzez symulację z rozkładu prawdopodobieństwa (wykorzystując genereator liczb losowych)    11.1.2 Symulacje geostatystyczne | Cel  Efekt symulacji ma bardziej realistyczny przestrzenny wzór (ang. pattern) niż kriging, którego efektem jest wygładzona reprezentacja rzeczywistości Każda z symulowanych map jest równie prawdopodobna Symulacje pozwalają na przedstawianie niepewności interpolacji Jednocześnie - kriging jest znacznie lepszy, gdy naszym celem jest jak najdokładniejsza predykcja     11.2 Typy symulacji  11.2.1 Typy symulacji  Symulacje bezwarunkowe (ang. Unconditional Simulations) - wykorzystuje semiwariogram, żeby włączyć informację przestrzenną, ale wartości ze zmierzonych punktów nie są wykorzystywane. Symulacje warunkowe (ang. Conditional Simulations) - opiera się ona o średnią wartość, strukturę kowariancji oraz obserwowane wartości     11.3 Symulacje bezwarunkowe  grid &lt;- read.csv(&#39;dane/siatka.csv&#39;) head(grid) ##       srtm clc      ndvi      savi        x        y ## 1       NA  NA 0.5179814 0.3308685 748826.7 721211.2 ## 2 240.9517   1 0.5275287 0.3408735 748916.7 721211.2 ## 3 238.6385   1 0.5066541 0.3252446 749006.7 721211.2 ## 4 237.6719   1 0.5220953 0.3370855 749096.7 721211.2 ## 5 235.7462   1 0.5240265 0.3384357 749186.7 721211.2 ## 6 230.6863   1 0.6171365 0.4051174 749276.7 721211.2 coordinates(grid) &lt;- ~x+y proj4string(grid) &lt;- proj4string(punkty) gridded(grid) &lt;- TRUE sym_bezw1 &lt;- krige(formula=z~1, locations=NULL, newdata=grid, dummy=TRUE,                          beta=1, model=vgm(psill=0.025,model=&#39;Exp&#39;,range=100), nsim=4, nmax=30) ## [using unconditional Gaussian simulation] spplot(sym_bezw1, main=&#39;Przestrzennie skorelowana powierzchnia \\nśrednia=1, sill=0.025, zasięg=100, model wykładniczy&#39;)  sym_bezw2 &lt;- krige(formula=z~1, locations=NULL, newdata=grid, dummy=TRUE,                     beta=1, model=vgm(psill=0.025,model=&#39;Exp&#39;,range=1500), nsim=4, nmax=30) ## [using unconditional Gaussian simulation] spplot(sym_bezw2, main=&#39;Przestrzennie skorelowana powierzchnia \\nśrednia=1, sill=0.025, zasięg=1500, model wykładniczy&#39;)     11.4 Symulacje warunkowe  11.4.1 Sekwencyjna symulacja gaussowska (ang. Sequential Gaussian simulation)  Wybranie lokalizacji nie posiadającej zmierzonej wartości badanej zmiennej Kriging wartości tej lokalizacji korzystając z dostepnych danych, co pozwala na uzyskanie rozkładu prawdopodobieństwa badanej zmiennej Wylosowanie wartości z rozkładu prawdopodobieństwa za pomocą generatora liczba losowych i przypisanie tej wartości do lokalizacji Dodanie symulowaniej wartości do zbioru danych i przejście do kolejnej lokalizacji Powtórzenie poprzednich kroków, aż do momentu gdy nie pozostanie już żadna nieokreślona lokalizacja    11.4.2 Sekwencyjna symulacja gaussowska (ang. Sequential Gaussian simulation) vario &lt;- variogram(temp~1, punkty) model &lt;- vgm(10, model = &#39;Sph&#39;, range = 4500, nugget=1) fitted &lt;- fit.variogram(vario, model) plot(vario, model=fitted)  sym_ok &lt;- krige(temp~1, punkty, grid, model=fitted, nsim=4, nmax=30) ## drawing 4 GLS realisations of beta... ## [using conditional Gaussian simulation] spplot(sym_ok)    11.4.3 Sekwencyjna symulacja gaussowska (ang. Sequential Gaussian simulation) sym_sk &lt;- krige(temp~1, punkty, grid, model=fitted, beta=15.324, nsim=100, nmax=30) ## [using conditional Gaussian simulation] sym_sk &lt;- stack(sym_sk) sym_sk_sd &lt;- calc(sym_sk, fun = sd) spplot(sym_sk_sd)     11.5 Sekwencyjna symulacja danych kodowanych (ang. Sequential indicator simulation)  11.5.1 Sekwencyjna symulacja danych kodowanych (ang. Sequential indicator simulation) summary(punkty$temp)  ##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  ##   8.153  12.460  15.210  15.520  18.260  26.700 punkty$temp_ind &lt;- punkty$temp &lt; 12 summary(punkty$temp_ind)  ##    Mode   FALSE    TRUE    NA&#39;s  ## logical     198      54       0 vario_ind &lt;- variogram(temp_ind~1, punkty)          plot(vario_ind)  model_ind &lt;- vgm(0.14, model = &#39;Sph&#39;, range = 2000, nugget = 0.02) plot(vario_ind, model=model_ind)  fitted_ind &lt;- fit.variogram(vario_ind, model_ind) fitted_ind ##   model      psill    range ## 1   Nug 0.02543208    0.000 ## 2   Sph 0.13620532 1565.761 plot(vario_ind, model=fitted_ind)  sym_ind &lt;- krige(temp_ind~1, punkty, grid, model=fitted_ind, indicators=TRUE, nsim=4, nmax=30) ## drawing 4 GLS realisations of beta... ## [using conditional indicator simulation] spplot(sym_ind, main=&#39;Symulacje warunkowe&#39;)      "],
["bibliografia.html", "Rodział 12 Bibliografia", " Rodział 12 Bibliografia  "]
]
