---
knit: bookdown::preview_chapter
---

# Eksploracyjna analiza danych przestrzennych

```{r, interpolate_init}
library('geostatbook')
data(punkty)
data(granica)
```

## Mapy 

```{r, echo=FALSE}
par(mar=c(rep(0, 4)))
```

### Podstawowe terminy | Kontekst przestrzenny
- Populacja - cały obszar, dla którego chcemy określić wybrane właściwości
- Próba - zbiór obserwacji, dla których mamy informacje. Inaczej, próba to podzbiór populacji. Zazwyczaj niemożliwe (lub bardzo kosztowne) jest zdobycie informacji o całej populacji. Z tego powodu bardzo cenne jest odpowiednie wykorzystanie informacji z próby.

### Mapy punktowe | Cel
- Sprawdzenie poprawności współrzędnych
- Wgląd w typ próbkowania
- Sprawdzenie poprawności danych - dane odstające lokalnie
- Identyfikacja głównych cech struktury przestrzennej zjawiska (np. trend)

## Próbkowanie

### Typy próbowania (oferowane przez pakiet `sp`)
- Regularny (ang.*regular*)
- Losowy (ang.*random*)
- Losowy stratyfikowany (ang.*stratified*)
- Preferencyjny (ang.*clustered*)

### Typ próbowania | Regularny

```{r }
set.seed(225)
regularny <- spsample(granica, 150, type = 'regular')
plot(regularny)
```

- Zmienna *offset*

### Typ próbowania | Losowy

```{r }
set.seed(301)
losowy <- spsample(granica, 150, type = 'random')
plot(losowy)
```

- Każda lokalizacja ma takie samo prawdopodobieństwo wystąpienia
- Każdy punkt jest losowany niezależnie od pozostałych

### Typ próbowania | Losowy stratyfikowany

```{r }
set.seed(125)
strat <- spsample(granica, 150, type = 'stratified')
plot(strat)
```

### Typ próbowania | Preferencyjny

```{r }
set.seed(425)
pref <- spsample(granica, 150, type = 'clustered', nclusters=30)
plot(pref)
```

### Mapy punktowe i dane lokalnie odstające

```{r}
data(granica)
plot(granica) 
plot(punkty, add=TRUE) 
```

```{r klik, eval=FALSE}
spplot(punkty, 'temp', identify=TRUE)
```

```{r }
spplot(punkty, 'temp', sp.layout = granica)
```

## Rozgrupowanie danych

### Rozgrupowanie danych
- Istnieje szereg metod rozgrupowywania danych, między innymi:
    - Rozgrupowywanie komórkowe
    - Rozgrupowywanie poligonowe
- Celem tych metod jest nadanie wag obserwacjom w celu zapewnienia reprezentatywności przestrzennej danych

### Rozgrupowanie danych

```{r }
data(punkty_pref)
spplot(punkty_pref, 'temp')
summary(punkty_pref$temp)
```

### Rozgrupowanie komórkowe I | (ang. *cell declustering*)

$$w'_j=\frac{\frac{1}{n_i}}{\text{liczba komórek z danymi}} \cdot n$$
, gdzie $n_i$ to liczba obserwacji w komórce, a $n$ to łączna liczba obserwacji

### Rozgrupowanie komórkowe I | (ang. *cell declustering*)

```{r }
data(punkty_pref)
punkty_pref$id <- 1:nrow(punkty_pref)
spplot(punkty_pref, 'id', colorkey=TRUE)

data(granica)
siatka_n <- raster(extent(gBuffer(granica, width = 500)))
res(siatka_n) <- c(1000, 1000)
siatka_n[] <- 0
proj4string(siatka_n) <- CRS(proj4string(punkty_pref))
siatka_n <- as(siatka_n, 'SpatialPolygonsDataFrame')
siatka_n <- siatka_n[!is.na(siatka_n@data$layer), ]
plot(siatka_n)
plot(punkty_pref, add=TRUE)

punkty_pref$liczebnosc <- rep(0, length(punkty_pref))
siatka_nr <- aggregate(punkty_pref['liczebnosc'], by = siatka_n, FUN = length) 
spplot(siatka_nr, 'liczebnosc')

liczba <- over(punkty_pref, siatka_nr)
punkty_pref$waga <- ((1/liczba$liczebnosc)/sum(!is.na(siatka_nr$liczebnosc))) * length(punkty_pref)

spplot(punkty_pref, 'waga')

srednia_arytmetyczna <- mean(punkty_pref$temp)
srednia_wazona_c1 <- mean(punkty_pref$temp * punkty_pref$waga, na.rm=TRUE)
```

### Rozgrupowanie komórkowe II | (ang. *cell declustering*)
<!--
- Przygotowanie danych
https://stat.ethz.ch/pipermail/r-sig-geo/2010-February/007710.html

When "interpolating" with nmax=1, you basically assign the value of the 
nearest observation to each grid cell, so, honoustly, it's hard to call 
this interpolation, it is rather something of a discretized Thiessen 
polygon.
-->

```{r }
data(punkty_pref)
punkty_pref$id <- 1:nrow(punkty_pref)
spplot(punkty_pref, 'id', colorkey=TRUE)

data(granica)
siatka_n <- raster(extent(gBuffer(granica, width = 500)))
res(siatka_n) <- c(100, 100)
siatka_n[] <- 0
proj4string(siatka_n) <- CRS(proj4string(punkty_pref))
# siatka_n <- mask(siatka_n, granica)
siatka_n <- as(siatka_n, 'SpatialPointsDataFrame')
siatka_n <- siatka_n[!is.na(siatka_n@data$layer), ]
gridded(siatka_n) <- TRUE
plot(siatka_n)
```

```{r }
out <-  krige(id~1, punkty_pref, siatka_n, nmax=1)
spplot(out, 'var1.pred')
df <- as.data.frame(table(out[[1]]))
df$waga <- df$Freq/sum(df$Freq)
punkty_pref <- merge(punkty_pref, df, by.x='id', by.y='Var1')
summary(punkty_pref$waga)
spplot(out, 'var1.pred', sp.layout=list('sp.points', punkty_pref))
spplot(punkty_pref['waga'])

srednia_arytmetyczna <- mean(punkty_pref$temp)
srednia_wazona_c2 <- sum(punkty_pref$temp * punkty_pref$waga, na.rm=TRUE)
```

### Rozgrupowanie poligonowe | (ang. *polygon declustering*)
$$w'_j=\frac{area_j}{\sum_{j=1}^{n}area_j} \cdot n$$
, gdzie $area_j$ powierzchnia dla wybranej obserwacji, a $n$ to łączna liczba obserwacji

### Rozgrupowanie poligonowe | (ang. *polygon declustering*)

```{r }
data(punkty_pref)
punkty_pref$id <- 1:nrow(punkty_pref)
spplot(punkty_pref, 'id', colorkey=TRUE)

v <- voronoi(punkty_pref)
plot(punkty_pref, cex=0.2, col='red')
plot(v, add=TRUE)

v$pow <- area(v)
v$waga <- v$pow/sum(v$pow) * length(punkty_pref)

punkty_pref <- merge(punkty_pref, v[c('id', 'waga')], by='id')
spplot(punkty_pref, 'waga')

srednia_arytmetyczna <- mean(punkty_pref$temp, na.rm=TRUE)
srednia_wazona_p <- mean(punkty_pref$temp*punkty_pref$waga, na.rm=TRUE)
```

```{r old_with_intersect, echo=FALSE, eval=FALSE}
data(punkty_pref)
punkty_pref$id <- 1:nrow(punkty_pref)
spplot(punkty_pref, 'id', colorkey=TRUE)

v <- voronoi(punkty_pref)
plot(punkty_pref, cex=0.2, col='red')
plot(v, add=TRUE)

v_intersect <- intersect(granica, v)
plot(punkty_pref, cex=0.2, col='red')
plot(v_intersect, add=TRUE)

v_intersect$pow <- area(v_intersect)
v_intersect$waga <- v_intersect$pow/sum(v_intersect$pow) * length(punkty_pref)

punkty_pref <- merge(punkty_pref, v_intersect[c('id', 'waga')], by='id')
spplot(punkty_pref, 'waga')

srednia_arytmetyczna <- mean(punkty_pref$temp, na.rm=TRUE)
srednia_wazona_p <- mean(punkty_pref$temp*punkty_pref$waga, na.rm=TRUE)
```


```{r tab_dec_1, echo=FALSE}
library('knitr')
srednia_arytmetyczna_pop <- 15.5912781
df <- data.frame(sa=c(srednia_arytmetyczna_pop, srednia_arytmetyczna, srednia_wazona_c1, srednia_wazona_c2, srednia_wazona_p))
rownames(df) <- c('Populacja', 'Próba', "Rozgrupowanie komórkowe I", "Rozgrupowanie komórkowe II", "Rozgrupowanie poligonowe")
kable(df, col.names='Średnia arytmetyczna', row.names=TRUE)
```

<!--
polygon declustering - http://gis.stackexchange.com/questions/122376/cell-declustering-using-open-source-software
cell declustering - https://stat.ethz.ch/pipermail/r-sig-geo/2010-February/007710.html
http://gaa.org.au/pdf/DeclusterDebias-CCG.pdf
-->
