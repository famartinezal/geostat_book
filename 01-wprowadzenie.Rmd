---
knit: bookdown::preview_chapter
---

## R a dane przestrzenne
    
### Pakiety
    
- GIS - `sp`, `rgdal`, `raster`, `rasterVis`, `rgeos`, `maptools`, `GeoXp`, `deldir`, `pgirmess`
- Geostatystyka - `gstat`, `geoR`, `geoRglm`, `fields`, `spBayes`, `RandomFields`, `vardiag`
- Inne - `ggplot2`, `corrplot`, `caret`

```{r pakietyy}
pakiety <- c('caret', 'corrplot', 'dismo', 'fields', 'geoR', 'ggplot2', 'gridExtra', 'gstat', 'pgirmess', 'raster', 'rasterVis', 'rgdal', 'rgeos', 'sp')
```

```{r pakiety_inst, eval=FALSE}
install.packages(pakiety)
```

Pakiety R oraz zbiory danych używane w tej książce można również zainstalować poprzez:

```{r, eval=FALSE}
devtools::install_github("nowosad/geostatbook")
```

```{r, echo=FALSE, eval=FALSE}
devtools::session_info(pakiety)
```

### Reprezentacja danych nieprzestrzennych
    
- Wektory (ang. *vector*):
    - liczbowe (ang. *integer*, *numeric*) - c(1, 2, 3) i c(1.21, 3.32, 4.43)
    - znakowe (ang. *character*) - c('jeden', 'dwa', 'trzy')
    - logiczne (ang. *logical*) - c(TRUE, FALSE)
    - czynnikowe (ang. *factor*) - c('jeden', 'dwa', 'trzy', 'jeden')
- Ramki danych (ang. *data.frame*) - to zbiór zmiennych (kolumn) oraz obserwacji (wierszy) zawierających różne typy danych
- Macierze (ang. *matrix*)
- Listy (ang. *list*)

### Reprezentacja danych przestrzennych

- Obiekty klasy `Spatial*` z pakietu `sp` - wszystkie z nich zawierają dwie dodatkowe informacje:
    - bounding box (`bbox`) - obwiednia - określa zasięg danych
    - CRS (`proj4string`) - układ współrzędnych
- Najczęściej stosowane obiekty klasy `Spatial*` to `SpatialPointsDataFrame`, `SpatialPolygonsDataFrame` oraz `SpatialGridDataFrame`
- Obiekty klasy `Raster*` z pakietu `raster`, tj. `RasterLayer`, `RasterStack`, `RasterBrick`
- Inne

### GDAL/OGR
- http://www.gdal.org/
- GDAL to biblioteka zawierająca funkcje służące do odczytywania i zapiswania danych w formatach rastrowych
- OGR to bibioteka służąca to odczytywania i zapiswania danych w formatach wektorowych
- Pakiet `rgdal` pozwala na wykorzystanie bibliotek GDAL/OGR w R

### PROJ.4
- Dane przestrzenne powinny być zawsze powiązane z układem współrzednych
- PROJ.4 - to biblioteka pozwalająca na identyfiację oraz konwersję pomiędzy różnymi układami współrzędnych
http://www.spatialreference.org/

### EPSG
- Kod EPSG (ang. *European Petroleum Survey Group*) pozwala na łatwe identyfikowanie układów współrzędnych
- Przykładowo, układ PL 1992 może być określony jako:

"+proj=tmerc +lat_0=0 +lon_0=19 +k=0.9993 +x_0=500000 +y_0=-5300000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs"

- ...lub też za pomocą kodu EPSG:

"+init=epsg:2180"

### Układ geograficzny
- Proporcje pomiędzy współrzedną oznaczjącą długość geograficzną (X) a oznaczającą szerokość geograficzną (Y) nie są równe 1:1
- Wielkość oczka siatki jest zmienna 
- Nie pozwala to na proste określanie odległości czy powierzchni
- Jednostka mapy jest abstrakcyjna

- Do większości algorytmów w geostatystyce wykorzystywane są układy współrzędnych prostokątnych płaskich

## Import danych

### Dane punktowe (format csv)

```{r}
dane_punktowe <- read.csv('dane/punkty.csv')
```

```{r}
head(dane_punktowe)
```

```{r}
coordinates(dane_punktowe) <- ~x+y
summary(dane_punktowe)
```

```{r}
proj4string(dane_punktowe) <- '+init=epsg:2180'
summary(dane_punktowe)
```

<!--
### Usuwanie punktów zawierających braki wartości

```{r }
sp_na_omit <- function(x, margin=1) {
    if (!inherits(x, "SpatialPointsDataFrame") & !inherits(x, "SpatialPolygonsDataFrame")) 
        stop("MUST BE sp SpatialPointsDataFrame OR SpatialPolygonsDataFrame CLASS OBJECT") 
    na.index <- unique(as.data.frame(which(is.na(x@data),arr.ind=TRUE))[,margin])
    if(margin == 1) {  
        cat("DELETING ROWS: ", na.index, "\n") 
        return( x[-na.index,]  ) 
    }
    if(margin == 2) {  
        cat("DELETING COLUMNS: ", na.index, "\n") 
        return( x[,-na.index]  ) 
    }
}
# wolin_lato_los2 <- sp_na_omit(wolin_lato_los) 
# summary(wolin_lato_los2)
```
-->

### Dane poligonowe (formaty gisowe)

```{r}
granica <- readOGR(dsn='dane', layer='granica', verbose=FALSE)
plot(granica)
```

### Rastry

```{r}
siatka_raster <- raster('dane/siatka.tif')
plot(siatka_raster)
```

## Eksport danych

### Zapisywanie danych wektorowych

```{r zapis_wektora, eval=FALSE}
writeOGR(poligon, dsn='nazwa_folderu', layer='nowy_poligon', driver='ESRI Shapefile')
```

### Zapisywanie danych rastrowych

```{r zapis_rastra, eval=FALSE}
writeRaster(siatka_raster, filename='nazwa_folderu/nowy_raster.tif')
```

## Wizualizacja danych 2D

### Dane punktowe

```{r}
plot(dane_punktowe)
```

```{r }
spplot(dane_punktowe, 'temp')
```

```{r }
spplot(dane_punktowe, 'srtm')
```

### Dane punktowe - kategorie

```{r }
dane_punktowe@data$clc <- as.factor(dane_punktowe@data$clc)
spplot(dane_punktowe, 'clc')
```

### Rastry

```{r, message=FALSE, warning=FALSE}
levelplot(siatka_raster, margin=FALSE)
```

## Tworzenie siatek
### Siatki regularne

```{r}
bbox(dane_punktowe)
extent(dane_punktowe)
```

```{r }
siatka <- expand.grid(x = seq(from = 745050, to = 757050, by = 500),
                      y = seq(from = 712650, to = 721650, by = 500))
coordinates(siatka) <- ~x + y
gridded(siatka) <- TRUE
proj4string(siatka) <- proj4string(dane_punktowe)
```

```{r}
siatka <- makegrid(dane_punktowe, cellsize=500)
names(siatka) <- c('x', 'y')
coordinates(siatka) <- ~x + y
gridded(siatka) <- TRUE
proj4string(siatka) <- proj4string(dane_punktowe)
```

### Siatki regularne

```{r }
plot(siatka)
plot(dane_punktowe, add=TRUE)
```

### Siatki nieregularne - klasa `RasterLayer`

```{r }
granica <- readOGR(dsn='dane', layer='granica')
siatka_n <- raster(extent(granica))
res(siatka_n) <- c(500, 500)
siatka_n[] <- 0
proj4string(siatka_n) <- proj4string(granica)
siatka_n <- mask(siatka_n, granica)
```

```{r }
levelplot(siatka_n, margin=FALSE)
```

### Siatki nieregularne - klasa `SpatialPixelsDataFrame`

```{r }
siatka_n <- as(siatka_n, 'SpatialPointsDataFrame')
siatka_n <- siatka_n[!is.na(siatka_n@data$layer), ]
gridded(siatka_n) <- TRUE
plot(siatka_n)
```
